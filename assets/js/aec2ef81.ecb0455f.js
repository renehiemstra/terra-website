"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[3254],{1991:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"standard-library/allocators/intro","title":"Allocators in Terra","description":"Allocators empower users with fine-grained control over the memory management of individual objects. By selecting an appropriate allocation strategy, users can dictate the memory source\u2014such as stack, heap, or shared memory\u2014tailoring it to specific needs. For instance, short-lived temporary objects can leverage fast, fixed-size stack allocations, while long-running processes can benefit from strategies that minimize fragmentation. Moreover, allocators enhance performance by improving locality of reference, colocating related objects in memory to optimize access patterns.","source":"@site/docs/standard-library/allocators/intro.md","sourceDirName":"standard-library/allocators","slug":"/standard-library/allocators/intro","permalink":"/terra-website/docs/standard-library/allocators/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/standard-library/allocators/intro.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Terra\'s Standard Library","permalink":"/terra-website/docs/standard-library/intro"},"next":{"title":"Design of allocators in terra","permalink":"/terra-website/docs/standard-library/allocators/design"}}');var o=r(4848),n=r(8453);const i={},s="Allocators in Terra",l={},c=[{value:"Design of allocators in terra",id:"design-of-allocators-in-terra",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"allocators-in-terra",children:"Allocators in Terra"})}),"\n",(0,o.jsx)(t.p,{children:"Allocators empower users with fine-grained control over the memory management of individual objects. By selecting an appropriate allocation strategy, users can dictate the memory source\u2014such as stack, heap, or shared memory\u2014tailoring it to specific needs. For instance, short-lived temporary objects can leverage fast, fixed-size stack allocations, while long-running processes can benefit from strategies that minimize fragmentation. Moreover, allocators enhance performance by improving locality of reference, colocating related objects in memory to optimize access patterns."}),"\n",(0,o.jsx)(t.p,{children:"In Terra, we've designed an allocator system that prioritizes simplicity, extensibility, composability, and integration with the language's low-level capabilities, while avoiding the pitfalls of overly complex or rigid designs seen in other languages like C++. We also make it really easy to implement your own allocator."}),"\n",(0,o.jsx)(t.p,{children:"Here we outline the design of the allocator class, a lightweight yet powerful abstraction that empowers developers to manage memory efficiently in Terra."}),"\n",(0,o.jsx)(t.h2,{id:"design-of-allocators-in-terra",children:"Design of allocators in terra"}),"\n",(0,o.jsx)(t.p,{children:"The overall design is based on the following key ideas:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["A container\u2019s ",(0,o.jsx)(t.code,{children:"new"})," method (or any factory function producing a container object) accepts an allocator by reference as an opaque object conforming to the allocator interface. This approach decouples the allocator type from the container type, eliminating the need for a template parameter to support generic allocators. This addresses a notable limitation in the C++ Standard Library, where the allocator template parameter must be specified for every container method\u2014a cumbersome requirement. For further insight into this challenge, refer to the BDE allocator model. ",(0,o.jsx)(t.a,{href:"https://github.com/bloomberg/bde/wiki/BDE-Allocator-Model",children:"BDE allocator model"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["An abstraction of a memory block that has a notion of its allocator and a notion of its size. It can therefore 'free' its own resource when it runs out of scope or it can ask for additional resources when the current resource is too small. All is packed in an economical, single-function interface, ispired by 'lua_Alloc'. See also the ",(0,o.jsx)(t.a,{href:"https://nullprogram.com/blog/2023/12/17/",children:"allocator API for C"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Every allocator has an 'owns' method, which enables composable allocators (see Andrei Alexandrescu's talk on ",(0,o.jsx)(t.a,{href:"https://www.youtube.com/watch?v=LIb3L4vKZ7U&t=21s",children:"composable allocators in C++"}),")."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>s});var a=r(6540);const o={},n=a.createContext(o);function i(e){const t=a.useContext(n);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(n.Provider,{value:t},e.children)}}}]);