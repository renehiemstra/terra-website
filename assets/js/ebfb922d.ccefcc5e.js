"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[1521],{4217:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>i});const l=JSON.parse('{"id":"standard-library/allocators/custom-allocators","title":"Custom Allocators","description":"Custom alloctors can be implemented easily by defining a new class that satisfies the low-level allocator interface. By calling a base class the allocator user-interface is automatically generated.","source":"@site/docs/standard-library/allocators/custom-allocators.md","sourceDirName":"standard-library/allocators","slug":"/standard-library/allocators/custom-allocators","permalink":"/terra-website/docs/standard-library/allocators/custom-allocators","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/standard-library/allocators/custom-allocators.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Allocator interface","permalink":"/terra-website/docs/standard-library/allocators/interface"},"next":{"title":"Concepts","permalink":"/terra-website/docs/standard-library/concepts/intro"}}');var a=t(4848),o=t(8453);const s={},r="Custom Allocators",c={},i=[{value:"Implementing a new allocator",id:"implementing-a-new-allocator",level:2},{value:"The allocator base class",id:"the-allocator-base-class",level:3},{value:"Use in containers",id:"use-in-containers",level:2},{value:"Recursive datastructures",id:"recursive-datastructures",level:2},{value:"To do:",id:"to-do",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"custom-allocators",children:"Custom Allocators"})}),"\n",(0,a.jsx)(n.p,{children:"Custom alloctors can be implemented easily by defining a new class that satisfies the low-level allocator interface. By calling a base class the allocator user-interface is automatically generated."}),"\n",(0,a.jsx)(n.h2,{id:"implementing-a-new-allocator",children:"Implementing a new allocator"}),"\n",(0,a.jsx)(n.p,{children:"Implementing a new allocator is easy. Given a struct"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-terra",children:'local myallocator = terralib.newstruct("myallocator")\n'})}),"\n",(0,a.jsx)(n.p,{children:"the following (lowlevel) interface should be implemented:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-terra",children:"myallocator.methods.__allocate :: {&block, size_t, size_t} -> {}   \nmyallocator.methods.__deallocate :: {&block} -> {}\nmyallocator.methods.__reallocate :: {&block, size_t, size_t} -> {}\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"Finally, by calling the following base class the implementation is completed:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-terra",children:"AllocatorBase(myallocator)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["For an example, please have a look at the corresponding implementation of the ",(0,a.jsx)(n.code,{children:"DefaultAllocator"})," that uses malloc/free."]}),"\n",(0,a.jsx)(n.h3,{id:"the-allocator-base-class",children:"The allocator base class"}),"\n",(0,a.jsxs)(n.p,{children:["The allocator base class generates and completes the implementation of ",(0,a.jsx)(n.code,{children:"myallocator"}),". It implements the following basic interfaces"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-terra",children:"function AllocatorBase(A)\n\n    A.methods.owns :: {&A, blk : &block} -> bool\n    \n    A.methods.__allocators_best_friend :: {&A, &block, size_t, size_t} -> {}\n\n    A.methods.allocate :: {&A, &block, size_t, size_t} -> {block}\n    A.methods.deallocate :: {&A, &block} -> {}\n    A.methods.reallocate :: {&A, &block, size_t, size_t} -> {}\n\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We already covered the implementation of ",(0,a.jsx)(n.code,{children:"owns"}),". The implementation of ",(0,a.jsx)(n.code,{children:"__allocators_best_friend"})," is also straightforward. It looks like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-terra",children:"terra A:__allocators_best_friend(blk : &block, size : size_t, counter : size_t)\n    var requested_bytes = size * counter\n    if blk:isempty() and requested_bytes > 0 then\n        self:allocate(blk, size, counter)\n    else\n        if requested_bytes == 0 then\n            --free memory\n            self:deallocate(blk)\n        elseif requested_bytes > blk:size_in_bytes() then\n            --reallocate memory\n            self:reallocate(blk, size, counter)\n        end\n    end\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The idea of wrapping the three key allocator functions in one function is inspired from Lua's  lua_Alloc. See also the blog post on an ",(0,a.jsx)(n.a,{href:"https://nullprogram.com/blog/2023/12/17/",children:"allocator API for C"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Let's look at the ",(0,a.jsx)(n.code,{children:"allocate"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-terra",children:"terra A:allocate(blk : &block, elsize : size_t, counter : size_t)    \n    var blk = Imp.__allocate(elsize, counter)\n    blk.alloc = self\n    return blk\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The implementation of ",(0,a.jsx)(n.code,{children:"__allocate"}),", ",(0,a.jsx)(n.code,{children:"__reallocate"})," and ",(0,a.jsx)(n.code,{children:"__deallocate"})," is specific to each allocator."]}),"\n",(0,a.jsx)(n.h2,{id:"use-in-containers",children:"Use in containers"}),"\n",(0,a.jsxs)(n.p,{children:["Here follows an example of a simple ",(0,a.jsx)(n.code,{children:"DynamicStack"})," class. A couple of interesting things are the following:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The allocator is not passed as a template type parameter!"}),"\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.code,{children:"__dtor"})," method need not be implemented to release the dynamic resources. One is generated automatically since ",(0,a.jsx)(n.code,{children:"__dtor"})," is implemented for ",(0,a.jsx)(n.code,{children:"block"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["In ",(0,a.jsx)(n.code,{children:"new"})," an opaque ",(0,a.jsx)(n.code,{children:"block"})," is automatically cast to a ",(0,a.jsx)(n.code,{children:"S = alloc.SmartBlock(T)"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.code,{children:"get"})," and ",(0,a.jsx)(n.code,{children:"set"})," method is available for SmartBlock objects of type ",(0,a.jsx)(n.code,{children:"S"}),". Essentially, ",(0,a.jsx)(n.code,{children:"S = alloc.SmartBlock(T)"})," is a smart pointer type."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-terra",children:'local alloc = require("alloc")\n\nlocal Allocator = alloc.Allocator\n\nlocal size_t = uint64\n\nlocal DynamicStack = terralib.memoize(function(T)\n\n    local S = alloc.SmartBlock(T)\n    S:complete()\n\n    local struct stack{\n        data: S\n    }\n\n    stack.staticmethods = {}\n\n    stack.staticmethods.new = terra(alloc : Allocator, size: size_t)\n        return stack{alloc:allocate(sizeof(T), size)}\n    end\n\n    stack.metamethods.__getmethod = function(self, methodname)\n        return self.methods[methodname] or stack.staticmethods[methodname]\n    end\n\n    terra stack:size()\n        return self.data:size()\n    end\n\n    terra stack:get(i : size_t)\n        return self.data:get(i)\n    end\n\n    terra stack:set(i : size_t, v : T)\n        self.data:set(i, v)\n    end\n\n    return stack\nend)\n'})}),"\n",(0,a.jsx)(n.p,{children:"The above class can be used as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-terra",children:'local stack = DynamicStack(double)\nlocal DefaultAllocator =  alloc.DefaultAllocator()\n\nterra main()\n    var alloc : DefaultAllocator\n    var x = stack.new(&alloc, 2)\n    x:set(0, 1.0)\n    x:set(1, 2.0)\n    io.printf("value of x[0] is: %f\\n", x:get(0))\n    io.printf("value of x[1] is: %f\\n", x:get(1))\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"recursive-datastructures",children:"Recursive datastructures"}),"\n",(0,a.jsxs)(n.p,{children:["Recursive datastructures, such as linked lists can be implemented using specialized ",(0,a.jsx)(n.code,{children:"__dtor"}),"'s and keeping an array of nodes, or, directly, using smart blocks. The implementation of ",(0,a.jsx)(n.code,{children:"block"})," supports automatic destruction of recursive datastructures, and even cycles. Here follows an example of a cyclical double linked list:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-terra",children:'local alloc = require("alloc")\n\nlocal DefaultAllocator = alloc.DefaultAllocator()\nlocal Allocator = alloc.Allocator\n\n--implementation of double-linked list\nlocal struct d_node\nlocal smrt_d_node = alloc.SmartBlock(d_node)\n\n--metamethod used here for testing - counting the number\n--of times the __dtor method is called\nlocal smrt_d_node_dtor_counter = global(int, 0)\nsmrt_d_node.metamethods.__dtor = macro(function(self)\n    return quote\n        if self:owns_resource() then\n            smrt_d_node_dtor_counter  = smrt_d_node_dtor_counter + 1\n        end\n    end\nend)\n\nsmrt_d_node.metamethods.__entrymissing = macro(function(entryname, self)\n    return `self.ptr.[entryname]\nend)\n\nsmrt_d_node.metamethods.__methodmissing = macro(function(method, self, ...)\n    local args = terralib.newlist{...}\n    return `self.ptr:[method](args)\nend)\n\nstruct d_node{\n    index : int\n    prev : smrt_d_node\n    next : smrt_d_node\n}\nd_node:complete()\n\n\nsmrt_d_node.metamethods.__eq = terra(self : &smrt_d_node, other : &smrt_d_node)\n    if not self:isempty() and not other:isempty() then\n        return self.ptr == other.ptr\n    end\n    return false\nend\n\nterra smrt_d_node:allocate_next(A : Allocator)\n    self.next = A:allocate(sizeof(d_node), 1)\n    self.next.index = self.index + 1\n    self.next.prev = self --create a view\nend\n\nterra smrt_d_node:set_next(next : &smrt_d_node)\n    self.next = next  --create a view\nend\n\nterra smrt_d_node:set_prev(prev : &smrt_d_node)\n    self.prev = prev  --create a view\nend\n\nterra main()\n    smrt_d_node_dtor_counter = 0\n    do\n        --define head node\n        var head : smrt_d_node = A:allocate(sizeof(d_node), 1)\n        head.index = 0\n        --make allocations\n        head:allocate_next(&A)  --node 1\n        head.next:allocate_next(&A) --node 2\n        head.next.next:allocate_next(&A) --node 3\n        --close loop\n        head:set_prev(&head.next.next.next)\n        head.next.next.next:set_next(&head) --node 3\n    end\n    return smrt_d_node_dtor_counter\nend\n--check that destructor is called four times\nassert(main() == 4) \n'})}),"\n",(0,a.jsx)(n.h2,{id:"to-do",children:"To do:"}),"\n",(0,a.jsx)(n.p,{children:"The following things remain:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The current implementation of ",(0,a.jsx)(n.code,{children:"block.methods.__dtor"})," relies on recursion. LLVM may not be able to fully optimize the recursion to a loop, which may seriously limit the size of such datastrutures due to limits in stack-space. In the near future I will rewrite the algorithm using a while loop."]}),"\n",(0,a.jsxs)(n.li,{children:["Right now only a default allocator is implemented based on ",(0,a.jsx)(n.code,{children:"malloc"}),", ",(0,a.jsx)(n.code,{children:"realloc"}),", ",(0,a.jsx)(n.code,{children:"calloc"})," and ",(0,a.jsx)(n.code,{children:"aligned_alloc"}),". Other standard allocators need to be implemented, such as, a 'stack', 'arena', 'freelist' allocators, etc."]}),"\n",(0,a.jsx)(n.li,{children:"Functionality for composing allocators to build new ones."}),"\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.code,{children:"SmartBlock(T)"})," can already be cast to a ",(0,a.jsx)(n.code,{children:"SmartBlock(vector(T))"})," for primitive types ",(0,a.jsx)(n.code,{children:"T"}),". By adding a ",(0,a.jsx)(n.code,{children:"__for"})," metamethod it would become possible to iterate over a ",(0,a.jsx)(n.code,{children:"SmartBlock(vector(T))"})," and enable 'SIMD' instructions in a range for loop."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var l=t(6540);const a={},o=l.createContext(a);function s(e){const n=l.useContext(o);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),l.createElement(o.Provider,{value:n},e.children)}}}]);