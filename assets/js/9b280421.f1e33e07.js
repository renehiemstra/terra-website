"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[5387],{8453:(e,s,r)=>{r.d(s,{R:()=>t,x:()=>a});var n=r(6540);const i={},o=n.createContext(i);function t(e){const s=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),n.createElement(o.Provider,{value:s},e.children)}},8928:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>t,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"core-language/resource-management/comparison","title":"Comparisons with C++ and Rust","description":"Terra\u2019s resource management system harmonizes C++\u2019s control with Rust\u2019s ownership principles, emphasizing both simplicity and efficiency. Compared to C++, Terra forgoes certain flexibilities, such as constructors, in favor of a concise Rule of Three (init, copy, dtor) characterized by simple and safe rules. It enhances performance over C++ for R-values by consistently employing a bitwise copy (memcpy), avoiding C++\u2019s potential for implicit copying or dependence on optimizations.","source":"@site/docs/core-language/resource-management/comparison.md","sourceDirName":"core-language/resource-management","slug":"/core-language/resource-management/comparison","permalink":"/terra-website/docs/core-language/resource-management/comparison","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/core-language/resource-management/comparison.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Ownership model","permalink":"/terra-website/docs/core-language/resource-management/ownership-model"},"next":{"title":"Tutorial - Move semantics in Terra","permalink":"/terra-website/docs/core-language/resource-management/tutorial/move-semantics"}}');var i=r(4848),o=r(8453);const t={},a="Comparisons with C++ and Rust",c={},l=[{value:"Terra vs. C++",id:"terra-vs-c",level:2},{value:"Similarities",id:"similarities",level:3},{value:"Differences",id:"differences",level:3},{value:"Terra vs. Rust",id:"terra-vs-rust",level:2},{value:"Similarities",id:"similarities-1",level:3},{value:"Differences",id:"differences-1",level:3}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"comparisons-with-c-and-rust",children:"Comparisons with C++ and Rust"})}),"\n",(0,i.jsxs)(s.p,{children:["Terra\u2019s resource management system harmonizes C++\u2019s control with Rust\u2019s ownership principles, emphasizing both simplicity and efficiency. Compared to C++, Terra forgoes certain flexibilities, such as constructors, in favor of a concise Rule of Three (",(0,i.jsx)(s.code,{children:"__init"}),", ",(0,i.jsx)(s.code,{children:"__copy"}),", ",(0,i.jsx)(s.code,{children:"__dtor"}),") characterized by simple and safe rules. It enhances performance over C++ for R-values by consistently employing a bitwise copy (memcpy), avoiding C++\u2019s potential for implicit copying or dependence on optimizations."]}),"\n",(0,i.jsxs)(s.p,{children:["Relative to Rust, Terra offers increased flexibility at the expense of some safety assurances. Both languages emphasize efficient defaults, yet Terra\u2019s consistent R-value moves avoid the copying that Rust applies to Copy types. Upcoming safety features, like compile-time initialization checks and read-only borrowing with ",(0,i.jsx)(s.code,{children:"const&"}),", will boost Terra\u2019s safety, getting closer to Rust\u2019s strictness while keeping its flexible design."]}),"\n",(0,i.jsx)(s.h2,{id:"terra-vs-c",children:"Terra vs. C++"}),"\n",(0,i.jsx)(s.h3,{id:"similarities",children:"Similarities"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Explicit memory management"}),": Both leverage explicit memory management (Terra via C\u2019s ",(0,i.jsx)(s.code,{children:"malloc"}),"/",(0,i.jsx)(s.code,{children:"free"}),", C++ via ",(0,i.jsx)(s.code,{children:"new"}),"/",(0,i.jsx)(s.code,{children:"delete"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Assignment Operators"}),": Terra\u2019s ",(0,i.jsx)(s.code,{children:"__copy"})," resembles C++\u2019s copy assignment operator (",(0,i.jsx)(s.code,{children:"operator="}),")."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Read-Only References"}),": Planned ",(0,i.jsx)(s.code,{children:"const&"})," mirrors C++\u2019s ",(0,i.jsx)(s.code,{children:"const T&"})," for read-only access."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"differences",children:"Differences"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Simplicity"}),": Terra's rule of three (",(0,i.jsx)(s.code,{children:"__init"}),", ",(0,i.jsx)(s.code,{children:"__copy"}),", ",(0,i.jsx)(s.code,{children:"__dtor"}),") reduces boilerplate by omitting constructors, while C++'s rule of five requires destructor, copy/move constructors, and copy/move assignment."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"R-Value Handling"}),": Terra always moves R-values with memcpy, enhancing performance over C++\u2019s potential deep-copying or reliance on optimizations."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"L-Value Handling"}),": Terra invokes a move for L-values by default (when ",(0,i.jsx)(s.code,{children:"__copy"})," is not implemented), ensuring explicit transfer, whereas C++ may copy unless an explicit move is implemented."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Defaults"}),": Terra auto-generates ",(0,i.jsx)(s.code,{children:"__move"})," for managed types and ",(0,i.jsx)(s.code,{children:"__copy"})," for aggregrate copyable manged types; C++ defaults to shallow copies unless overridden."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"terra-vs-rust",children:"Terra vs. Rust"}),"\n",(0,i.jsx)(s.h3,{id:"similarities-1",children:"Similarities"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Single Ownership"}),": Both ensure one owner per resource, preventing data races."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Move-by-Default"}),": Terra and Rust move resources unless copying is opted in (",(0,i.jsx)(s.code,{children:"__copy"})," vs. ",(0,i.jsx)(s.code,{children:"Copy"})," trait)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Efficient Defaults"}),": Both prioritize performance, with Terra and Rust moving non-copyable types efficiently."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"differences-1",children:"Differences"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Copy Customization"}),": Terra\u2019s ",(0,i.jsx)(s.code,{children:"__copy"})," allows custom logic for L-values; Rust separates Copy (bitwise) and Clone (custom), applying Copy implicitly."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"R-Value Semantics"}),": Terra moves all R-values via memcpy; Rust copies R-values of Copy types, moving only non-Copy types."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Safety"}),": Rust\u2019s borrow checker offers stricter safety; Terra relies on planned features like initialization tracking and ",(0,i.jsx)(s.code,{children:"const&"})," that will bring it closer to Rust's safety features."]}),"\n"]})]})}function m(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);