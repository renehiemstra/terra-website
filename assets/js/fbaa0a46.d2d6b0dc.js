"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[2978],{645:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"features/domain-specific-languages","title":"Build your own DSL","description":"Domain-Specific Languages (DSLs) are specialized programming languages crafted to tackle specific types of problems\u2014think image processing, physical simulations, or financial modeling\u2014without the complexity of general-purpose languages like Python, Terra or C++. By focusing on what matters most in your field, DSLs streamline workflows, boost productivity, and bridge the gap between technical experts and domain specialists.","source":"@site/docs/features/domain-specific-languages.md","sourceDirName":"features","slug":"/features/domain-specific-languages","permalink":"/terra-website/docs/features/domain-specific-languages","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/features/domain-specific-languages.md","tags":[],"version":"current","frontMatter":{}}');var r=n(4848),o=n(8453);const i={},s="Build your own DSL",c={},l=[{value:"Brainfuck - a minimal language that emulates a Turing machine",id:"brainfuck---a-minimal-language-that-emulates-a-turing-machine",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"build-your-own-dsl",children:"Build your own DSL"})}),"\n",(0,r.jsx)(t.p,{children:"Domain-Specific Languages (DSLs) are specialized programming languages crafted to tackle specific types of problems\u2014think image processing, physical simulations, or financial modeling\u2014without the complexity of general-purpose languages like Python, Terra or C++. By focusing on what matters most in your field, DSLs streamline workflows, boost productivity, and bridge the gap between technical experts and domain specialists."}),"\n",(0,r.jsx)(t.p,{children:"Terra implements an API that makes it really easy to build your own language constructs with tailored syntax, abstractions, and tools that make coding faster, more intuitive, and less prone to error."}),"\n",(0,r.jsx)(t.h2,{id:"brainfuck---a-minimal-language-that-emulates-a-turing-machine",children:"Brainfuck - a minimal language that emulates a Turing machine"}),"\n",(0,r.jsxs)(t.p,{children:["With these two operators, you can use Lua to generate ",(0,r.jsx)(t.em,{children:"arbitrary"})," Terra code at compile-time. This makes the combination of Lua/Terra well suited for writing compilers for high-performance domain-specific languages. For instance, we can implement a ",(0,r.jsx)(t.em,{children:"compiler"})," for ",(0,r.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Brainfuck",children:"BF"}),", a minimal language that emulates a Turing machine. The Lua function ",(0,r.jsx)(t.code,{children:"compile"})," will take a string of BF code, and a maximum tape size ",(0,r.jsx)(t.code,{children:"N"}),". It then generates a Terra function that implements the BF code. Here is a skeleton that sets up the BF program:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-terra",children:"local function compile(code,N)\n    local function body(data,ptr)\n        --<<implementation of body>>\n    end\n    return terra()\n        --an array to hold the tape\n        var data : int[N]\n        --clear the tape initially\n        for i = 0, N do\n            data[i] = 0\n        end\n        var ptr = 0\n        --generate the code for the body\n        [ body(data,ptr) ]\n    end\nend\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The function ",(0,r.jsx)(t.code,{children:"body"})," is responsible for generating body of the BF program given the code string:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-terra",children:'local function body(data,ptr)\n    --the list of terra statements that make up the BF program\n    local stmts = terralib.newlist()\n\n    --loop over each character in the BF code\n    for i = 1,#code do\n        local c = code:sub(i,i)\n        local stmt\n        --generate the corresponding Terra statement\n        --for each BF operator\n        if c == ">" then\n            stmt = quote ptr = ptr + 1 end\n        elseif c == "<" then\n            stmt = quote ptr = ptr - 1 end\n        elseif c == "+" then\n            stmt = quote data[ptr] = data[ptr] + 1 end\n        elseif c == "-" then\n            stmt = quote data[ptr] = data[ptr] - 1 end\n        elseif c == "." then\n            stmt = quote C.putchar(data[ptr]) end\n        elseif c == "," then\n            stmt = quote data[ptr] = C.getchar() end\n        elseif c == "[" then\n            error("Implemented below")\n        elseif c == "]" then\n            error("Implemented below")\n        else\n            error("unknown character "..c)\n        end\n        stmts:insert(stmt)\n    end\n    return stmts\nend\n'})}),"\n",(0,r.jsxs)(t.p,{children:['It loops over the code string, and generates the corresponding Terra code for each character of BF (e.g. ">" shifts the tape over by 1 and is implemented by the Terra code ',(0,r.jsx)(t.code,{children:"ptr = ptr + 1"}),"). We can now compile a BF function:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-terra",children:'add3 = compile(",+++.")\n'})}),"\n",(0,r.jsxs)(t.p,{children:["The result, ",(0,r.jsx)(t.code,{children:"add3"}),", is a Terra function that adds3 to an input character and then prints it out:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-terra",children:"add3:printpretty()\n-- bf_t_46_1 = terra() : {}\n-- var data : int32[256]\n-- ...\n-- var ptr : int32 = 0\n-- data[ptr] = <extract0> #getchar()#\n-- data[ptr] = data[ptr] + 1\n-- data[ptr] = data[ptr] + 1\n-- data[ptr] = data[ptr] + 1\n-- <extract0> #putchar(data[ptr])#\n-- end\n"})}),"\n",(0,r.jsxs)(t.p,{children:["We can also use ",(0,r.jsx)(t.code,{children:"goto"})," statements (",(0,r.jsx)(t.code,{children:"goto labelname"}),") and labels (",(0,r.jsx)(t.code,{children:"::labelname::"}),") to implement BF's looping construct:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-terra",children:'local function body(data,ptr)\n    local stmts = terralib.newlist()\n    \n    --add a stack to keep track of the beginning of each loop\n    local jumpstack = {}\n    \n    for i = 1,#code do\n        local c = code:sub(i,i)\n        local stmt\n        --generate the corresponding Terra statement\n        --for each BF operator\n        if c == ">" then\n            stmt = quote ptr = ptr + 1 end\n        elseif c == "<" then\n            -- ...\n            -- handle \'+\', etc\n            -- ...\n        elseif c == "[" then\n            --generate labels to represent the beginning \n            --and ending of the loop\n            --the \'symbol\' function generates a globally unique\n            --name for the label\n            local target = { before = symbol(), after = symbol() }\n            table.insert(jumpstack,target)\n            stmt = quote \n                --label for beginning of the loop\n                ::[target.before]:: \n                if data[ptr] == 0 then\n                    goto [target.after] --exit the loop\n                end\n            end\n        elseif c == "]" then\n            --retrieve the labels that match this loop\n            local target = table.remove(jumpstack)\n            assert(target)\n            stmt = quote \n                goto [target.before] --loop back edge\n                :: [target.after] :: --label for end of the loop\n            end\n        else\n            error("unknown character "..c)\n        end\n        stmts:insert(stmt)\n    end\n    return stmts\nend\n'})}),"\n",(0,r.jsxs)(t.p,{children:["We are using these generative programming constructs to implement domain-specific languages and auto-tuners: check out our ",(0,r.jsx)(t.a,{href:"/publications.html",children:"PLDI paper"})," that describes our implementation of Orion, a language for image processing kernels, and ",(0,r.jsx)(t.a,{href:"http://ebblang.org/",children:"Ebb"}),", which is a DSL for solving mesh-based PDE's in Terra."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var a=n(6540);const r={},o=a.createContext(r);function i(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);