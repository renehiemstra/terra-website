"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[9017],{4853:(e,n,r)=>{r.d(n,{c:()=>t,x:()=>s});r(6540);var i=r(4848);const s=e=>{let{children:n}=e;return(0,i.jsx)("div",{style:{display:"flex",gap:"1rem",flexWrap:"wrap"},children:n})},t=e=>{let{children:n,title:r}=e;return(0,i.jsxs)("div",{style:{flex:1,minWidth:"300px"},children:[r&&(0,i.jsx)("div",{style:{color:"var(--ifm-font-color-base)",padding:"0.5rem 1rem",borderRadius:"var(--ifm-pre-border-radius, 4px) var(--ifm-pre-border-radius, 4px) 0 0",borderBottom:"none",fontSize:"0.9rem",fontWeight:"bold"},children:r}),(0,i.jsx)("div",{style:{marginTop:r?"0":"inherit",borderRadius:r?"0 0 var(--ifm-pre-border-radius, 4px) var(--ifm-pre-border-radius, 4px)":"var(--ifm-pre-border-radius, 4px)",overflow:"hidden"},children:n})]})}},5590:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>x,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"getting-started/terra-for-cpp","title":"Terra for C / C++ programmers","description":"Terra is a low-level, statically-typed language designed to interoperate seamlessly with Lua, offering semantics very similar to C/C++. However, its tight integration with Lua means that familiar C++ constructs are often expressed differently. This reference sheet bridges the gap by comparing C++ snippets with their Terra-Lua equivalents, helping C++ programmers transition to Terra. Where applicable, a third column illustrates how to meta-program these constructs using Lua\'s dynamic capabilities.","source":"@site/docs/getting-started/terra-for-cpp.mdx","sourceDirName":"getting-started","slug":"/getting-started/terra-for-cpp","permalink":"/terra-website/docs/getting-started/terra-for-cpp","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/getting-started/terra-for-cpp.mdx","tags":[],"version":"current","frontMatter":{"id":"terra-for-cpp","title":"Terra for C / C++ programmers"},"sidebar":"tutorialSidebar","previous":{"title":"Your first programm","permalink":"/terra-website/docs/getting-started/your-first-program"},"next":{"title":"intro","permalink":"/terra-website/docs/core-language/intro"}}');var s=r(4848),t=r(8453),a=r(4853);const l={id:"terra-for-cpp",title:"Terra for C / C++ programmers"},c="Terra for C / C++ programmers",o={},d=[{value:"Compilation Models",id:"compilation-models",level:2},{value:"Ahead-of-Time Compilation (C++)",id:"ahead-of-time-compilation-c",level:3},{value:"Dynamic Compilation (Lua / Python)",id:"dynamic-compilation-lua--python",level:3},{value:"Just-In-Time Compilation (Terra)",id:"just-in-time-compilation-terra",level:3},{value:"Contexts",id:"contexts",level:2},{value:"Preprocessor",id:"preprocessor",level:2},{value:"Using Multiple Files",id:"using-multiple-files",level:3},{value:"Using C Functions",id:"using-c-functions",level:3},{value:"Preprocessor Macro Equivalents:",id:"preprocessor-macro-equivalents",level:3},{value:"Macro functions:",id:"macro-functions",level:3},{value:"Conditional Compilation:",id:"conditional-compilation",level:3},{value:"Literals",id:"literals",level:2},{value:"Declarations and Type Constructors",id:"declarations-and-type-constructors",level:2},{value:"Declaring Variables",id:"declaring-variables",level:3},{value:"Sizing integer types:",id:"sizing-integer-types",level:3},{value:"Non-integer primitive types:",id:"non-integer-primitive-types",level:3},{value:"Multiple Declarations",id:"multiple-declarations",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Pointers and references",id:"pointers-and-references",level:3},{value:"Typedefs, constants, other",id:"typedefs-constants-other",level:3},{value:"Enums",id:"enums",level:3},{value:"Global (constant) values",id:"global-constant-values",level:2},{value:"Storage Classes",id:"storage-classes",level:2},{value:"Global Variables and Functions",id:"global-variables-and-functions",level:3},{value:"Local Static Variables",id:"local-static-variables",level:3},{value:"Statements",id:"statements",level:2},{value:"Assignements",id:"assignements",level:3},{value:"Declarations",id:"declarations",level:3},{value:"Semi-Colons",id:"semi-colons",level:3},{value:"Blocks",id:"blocks",level:3},{value:"Conditionals",id:"conditionals",level:3},{value:"Loops",id:"loops",level:3},{value:"Switch",id:"switch",level:3},{value:"Control Flow",id:"control-flow",level:3},{value:"Exceptions",id:"exceptions",level:3},{value:"Functions",id:"functions",level:2},{value:"Defining functions",id:"defining-functions",level:3},{value:"Declaring functions",id:"declaring-functions",level:3},{value:"Function Inlining",id:"function-inlining",level:3},{value:"Operator overloading",id:"operator-overloading",level:3},{value:"Function overloading",id:"function-overloading",level:3}];function h(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"terra-for-c--c-programmers",children:"Terra for C / C++ programmers"})}),"\n",(0,s.jsx)(n.p,{children:"Terra is a low-level, statically-typed language designed to interoperate seamlessly with Lua, offering semantics very similar to C/C++. However, its tight integration with Lua means that familiar C++ constructs are often expressed differently. This reference sheet bridges the gap by comparing C++ snippets with their Terra-Lua equivalents, helping C++ programmers transition to Terra. Where applicable, a third column illustrates how to meta-program these constructs using Lua's dynamic capabilities."}),"\n",(0,s.jsx)(n.h2,{id:"compilation-models",children:"Compilation Models"}),"\n",(0,s.jsxs)(n.p,{children:["Understanding how code is compiled and executed is key to grasping the differences between C++ and Terra. C++ relies on ",(0,s.jsx)(n.strong,{children:"ahead-of-time (AOT)"})," compilation, where all type checking, code generation, and optimization occur well before the program runs. In contrast, fully ",(0,s.jsx)(n.strong,{children:"dynamic"})," systems, like some interpreted languages, process code at runtime, allowing flexibility but sacrificing performance. Terra uses ",(0,s.jsx)(n.strong,{children:"just-in-time (JIT)"})," compilation, a hybrid approach that compiles code right before execution, blending the benefits of static type safety with runtime flexibility. This section explores these models, showing how they shape C++ and Terra\u2019s behavior."]}),"\n",(0,s.jsx)(n.h3,{id:"ahead-of-time-compilation-c",children:"Ahead-of-Time Compilation (C++)"}),"\n",(0,s.jsx)(n.p,{children:"In AOT compilation, the entire program is translated to machine code during a separate build phase, long before runtime. C++ exemplifies this model, using a preprocessor, compiler, and linker to produce an executable."}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int f() {\t\n    int a[3] = {0, 1, 2};\t\n    return a[0];\t\n}\t\nint main() {\t\n  return f();\n}\n"})})}),(0,s.jsxs)(a.c,{title:"C++ AOT compiler: ",children:[(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Preprocessor resolves ",(0,s.jsx)(n.code,{children:"#include"})," and macros."]}),"\n",(0,s.jsxs)(n.li,{children:["Compiler checks types (e.g., ",(0,s.jsx)(n.code,{children:"int[3]"}),") and generates object code."]}),"\n",(0,s.jsx)(n.li,{children:"Linker combines object files into an executable."}),"\n"]}),(0,s.jsx)(n.p,{children:"At runtime, the program executes directly with no further compilation."})]})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": AOT compilation ensures static type safety and optimization before execution, but it lacks runtime adaptability. All decisions (e.g., array sizes, types) are fixed at compile time."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dynamic-compilation-lua--python",children:"Dynamic Compilation (Lua / Python)"}),"\n",(0,s.jsx)(n.p,{children:"Dynamic systems interpret or compile code at runtime, often line-by-line, allowing types and structures to change during execution. This is common in languages like Python or Lua without JIT."}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"Python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def f():\n    a = [0, 1, 2]  # List, not a fixed array\n    a.append(3)    # Modified at runtime\n    return a[0]\n\nprint(f())\n"})})}),(0,s.jsx)(a.c,{title:"Python interpreter and dynamic compilation: ",children:(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["No ahead-of-time type checking\u2014",(0,s.jsx)(n.code,{children:"a"})," is dynamically typed."]}),"\n",(0,s.jsxs)(n.li,{children:["The list ",(0,s.jsx)(n.code,{children:"a"})," can grow or change during execution."]}),"\n",(0,s.jsx)(n.li,{children:"Performance is slower due to runtime interpretation, but flexibility is high."}),"\n"]})})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Dynamic compilation allows runtime modifications (e.g., resizing arrays), but it sacrifices the performance and type safety of compiled languages like C++."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"just-in-time-compilation-terra",children:"Just-In-Time Compilation (Terra)"}),"\n",(0,s.jsxs)(n.p,{children:["Terra\u2019s JIT compilation occurs right before runtime, when a ",(0,s.jsx)(n.code,{children:"terra"})," function is first invoked or explicitly compiled. Lua drives this process, defining types and generating code that is then fixed for execution, offering a balance between AOT\u2019s performance and dynamic compilation."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:'terra f()\n    var a : int[3] = array(0, 1, 2)\n    return a[0]\nend\n\n\nf()  -- Triggers JIT compilation\n\n-- AOT example:\nterralib.saveobj("f.so", { f = f })  -- Generates shared library\n'})})}),(0,s.jsxs)(a.c,{title:"Terra\u2019s JIT process: ",children:[(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Lua runs and defines ",(0,s.jsx)(n.code,{children:"f"})," at compiletime."]}),"\n",(0,s.jsxs)(n.li,{children:["On first call to ",(0,s.jsx)(n.code,{children:"f()"}),", Terra\u2019s JIT compiler checks types (e.g., ",(0,s.jsx)(n.code,{children:"int[3]"}),"), evaluates ",(0,s.jsx)(n.code,{children:"array(0, 1, 2)"}),", and generates machine code."]}),"\n",(0,s.jsxs)(n.li,{children:["The compiled ",(0,s.jsx)(n.code,{children:"f"})," executes with fixed types and sizes, reused on subsequent calls unless redefined."]}),"\n"]}),(0,s.jsxs)(n.p,{children:["For AOT, ",(0,s.jsx)(n.code,{children:"terralib.saveobj"})," compiles ",(0,s.jsx)(n.code,{children:"f"})," into a shared library (e.g., ",(0,s.jsx)(n.code,{children:"f.so"}),"), which can be linked into other programs, bypassing JIT at runtime."]})]})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Terra\u2019s JIT compilation happens just before runtime, locking in static definitions (e.g., ",(0,s.jsx)(n.code,{children:"int[3]"}),") once compiled. This contrasts with C++\u2019s AOT (done well before runtime) and dynamic systems (during runtime). Lua\u2019s role enables code generation (e.g., via ",(0,s.jsx)(n.code,{children:"quote"}),") during compile time, but the resulting Terra code is static in the runtime context."]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),': The "just in time" nature defers compilation until needed, improving startup speed for development while delivering near-AOT performance. Unlike dynamic systems, Terra\u2019s arrays and types cannot change mid-execution in the runtime context.']}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Terra\u2019s unique AOT support allows generating shared libraries (e.g., via ",(0,s.jsx)(n.code,{children:"terralib.saveobj"}),"), which can be linked against like C++ libraries. This offloads compilation from JIT to ahead-of-time, keeping JIT fast for development while enabling optimized, reusable binaries for deployment."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"contexts",children:"Contexts"}),"\n",(0,s.jsx)(n.p,{children:"In multistage programming, we distinguish between compile-time and runtime contexts. In C++, compile-time includes the preprocessor and template metaprogramming, while runtime encompasses regular function and variable definitions. Similarly, in Terra, the Lua context handles compile-time metaprogramming, and Terra functions define runtime behavior. Terra's semantics are very close to C/C++, but its integration with Lua introduces unique metaprogramming techniques through quotes (`) and escapes ([ ]), enabling dynamic code generation. This section compares equivalent representations in C++ and Terra, highlighting how contexts shift between compile-time and runtime."}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"-- Lua context (any Lua code here)\nMyInt = int -- assignment to Lua variable 'MyInt'\nx = global(MyInt)\n\nterra f()\n    -- Terra context\n    var bar : MyInt = x + 1\n    --        ~~~~~ _Lua_ context, any Lua can go here, but it needs to evaluate to a Terra type\n    return bar\nend\n\nstruct S {\n    a : int\n    --  ~~~ _Lua_ context, evaluates to a Terra type\n    b : float\n}\n\n-- Meta-programming Lua-Terra creates additional places where the context changes.\n\nfunction g() return `4+5 end\n--                  ~~~~ Terra context, a quote creates a Terra expression from Lua\n\nterra h()\n    var baz = [ g() ]\n    --        ~~~~~~~ Lua context, an escape breaks into Lua and evaluates to a Terra expression\nend\n"})})}),(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// function/global declaration context:\ntypedef int MyInt;\nMyInt x;\n\nint f() {\n    // C++ code context:\n    MyInt bar = x + 1;\n//  ~~~~~ C++ type context\n\n    return bar;\n}\n\nstruct S {\n    // struct definition context:\n    int a;\n // ~~~ type context\n    float b;\n};\n"})})})]}),"\n",(0,s.jsx)(n.h2,{id:"preprocessor",children:"Preprocessor"}),"\n",(0,s.jsx)(n.p,{children:"C++ uses a static preprocessor to manage file inclusion, macros, and conditional compilation, relying on a multi-step build process with separate compilation for custom C code and linking for standard libraries. Terra achieves similar functionality\u2014such as integrating external code and defining reusable constructs\u2014but replaces this static approach with a dynamic, Lua-driven model. By processing code, including C headers, at runtime within Terra\u2019s just-in-time (JIT) compilation pipeline, Lua offers a flexible alternative to C++\u2019s traditional preprocessing."}),"\n",(0,s.jsx)(n.h3,{id:"using-multiple-files",children:"Using Multiple Files"}),"\n",(0,s.jsxs)(n.p,{children:["In C++, ",(0,s.jsx)(n.code,{children:"#include"})," directives bring in external code. Terra uses Lua's require function to load modules, which can contain Terra functions and definitions stored in tables."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:'local myfile = require("myfile")\n-- use Lua\'s require to load another Lua \n-- file Terra functions can be stored in \n-- a table myfiles\nterra f()\n    myfile.myfunction()\nend\n'})})}),(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "myfile.h"\n\n\n\nvoid f() {\n    myfunction();\n}\n'})})})]}),"\n",(0,s.jsx)(n.h3,{id:"using-c-functions",children:"Using C Functions"}),"\n",(0,s.jsxs)(n.p,{children:["C++ uses ",(0,s.jsx)(n.code,{children:"#include"})," to access C standard library functions. Terra provides ",(0,s.jsx)(n.code,{children:"terralib.includec"})," and ",(0,s.jsx)(n.code,{children:"terralib.includecstring"})," to import C headers, creating a Lua table of functions and types."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:'local C = terralib.includecstring [[\n    #include<stdio.h>\n    #include<malloc.h\n]]\n-- can also use terralib.includec("stdio.h") for single file\n-- C is a table of functions (C.printf) and types (C.FILE)\nterra hello()\n    C.printf("hello, world\\n")\nend\n'})})}),(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <stdio.h>\n#include <malloc.h>\nint main() {\n    printf("hello, world\\n");\n}\n'})})})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Terra's ",(0,s.jsx)(n.code,{children:"includecstring"})," processes C headers at Lua runtime, generating bindings automatically. Unlike C++, no separate compilation step is needed\u2014Terra compiles these into the final executable alongside Terra code."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"preprocessor-macro-equivalents",children:"Preprocessor Macro Equivalents:"}),"\n",(0,s.jsxs)(n.p,{children:["Lua variables can hold values that get substituted into Terra functions. The quotation (`) operator creates a Terra expression directly from Lua. This value can be spliced into subsequent terra code using an escape: ",(0,s.jsx)(n.code,{children:"[ ... ]"}),"."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"local X = `3+3\n"})})}),(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#define X (3+3)\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"macro-functions",children:"Macro functions:"}),"\n",(0,s.jsx)(n.p,{children:"In Terra, a macro is a Lua function that returns a Terra expression that is directly spliced into surrounding Terra code. It's closely related to a macro function in C / C++."}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"local F = macro(function(a,b)\n    return `a + b\nend)\n"})})}),(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#define F(a,b) a + b\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"conditional-compilation",children:"Conditional Compilation:"}),"\n",(0,s.jsxs)(n.p,{children:["In C++, conditional compilation relies on the preprocessor\u2019s ",(0,s.jsx)(n.code,{children:"#ifdef"})," directives, which can feel rigid and obfuscated due to their static, text-based nature. Terra achieves the same functionality\u2014selectively defining code based on conditions\u2014using Lua\u2019s clear, dynamic syntax. By leveraging Lua\u2019s runtime logic, Terra offers a more readable and flexible alternative to C++\u2019s preprocessor calls."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:'-- use Lua to control how a Terra function is defined\nif terralib.os == "Windows" then\n    terra getOS() return "Windows" end\nelse\n    terra getOS() return "Linux" end\nend\n'})})}),(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Use #ifdef to control how functions are defined\n#ifdef __WIN32\n    char * getOS() { return "Windows"; }\n#else\n    char * getOS() { return "Linux"; }\n#endif\n'})})})]}),"\n",(0,s.jsx)(n.h2,{id:"literals",children:"Literals"}),"\n",(0,s.jsx)(n.p,{children:"C++ and Terra both support a variety of literal types (integers, floats, strings, booleans), but Terra\u2019s integration with Lua introduces differences in syntax and behavior. While C++ uses a static, compile-time approach to literals, Terra leverages Lua\u2019s dynamic runtime environment, often requiring escapes or Lua-specific constructs to achieve equivalent results. This table compares common literals in C++ with their Terra-Lua equivalents."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"C++"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Lua-Terra"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Description"})})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"255, 0377, 0xff"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"255, 0377, 0xff"})}),(0,s.jsx)(n.td,{children:"Integer literals in decimal (255), octal (0377), and hexadecimal (0xff) are identical in both languages, as Terra inherits C-like syntax for these."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"2147483647LL, 0x7ffffffful"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"2147483647LL, 0x7fffffffULL"})}),(0,s.jsxs)(n.td,{children:["Long integer literals in C++ use ",(0,s.jsx)(n.code,{children:"LL"})," or ",(0,s.jsx)(n.code,{children:"ul"})," suffixes. Terra matches LuaJIT\u2019s conventions, using ",(0,s.jsx)(n.code,{children:"LL"})," for signed long long and ",(0,s.jsx)(n.code,{children:"ULL"})," for unsigned long long, ensuring compatibility with Lua\u2019s number handling."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"123.0, 1.23e2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"123.0, 1.23e2"})}),(0,s.jsx)(n.td,{children:"Floating-point literals (decimal and scientific notation) are the same in both languages, reflecting C\u2019s influence on Terra\u2019s syntax."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'"strings\\n"'})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"\"strings\\n\" or 'strings\\n' or [[strings\\n]]"})}),(0,s.jsxs)(n.td,{children:["C++ uses double quotes for strings with escape sequences (e.g., ",(0,s.jsx)(n.code,{children:"\\n"}),"). Terra supports Lua\u2019s string styles: double quotes (",(0,s.jsx)(n.code,{children:'"..."'}),"), single quotes (",(0,s.jsx)(n.code,{children:"'...'"}),")\u2014which are equivalent\u2014or long brackets (",(0,s.jsx)(n.code,{children:"[[...]]"}),") for raw strings, avoiding escape sequence issues."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'a'"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'("a")[0]'})}),(0,s.jsxs)(n.td,{children:["C++ has single-character literals with single quotes. Terra lacks a direct char literal; instead, you index a string (e.g., ",(0,s.jsx)(n.code,{children:'"a"'}),") at position 0 to get a byte value, or you could define a function for this purpose."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'"hello" "world"'})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'[ "hello".."world" ]'})}),(0,s.jsxs)(n.td,{children:["C++ concatenates adjacent string literals at compile time. Terra uses Lua\u2019s ",(0,s.jsx)(n.code,{children:".."})," operator for string concatenation, wrapped in an escape (",(0,s.jsx)(n.code,{children:"[ ]"}),") to evaluate the Lua expression as a Terra-compatible string at runtime."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"true, false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"true, false"})}),(0,s.jsxs)(n.td,{children:["Boolean literals are identical in both languages, as Terra adopts C++\u2019s ",(0,s.jsx)(n.code,{children:"true"})," and ",(0,s.jsx)(n.code,{children:"false"})," directly."]})]})]})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": C++ literals are resolved statically at compile time, with types inferred by the compiler (e.g., ",(0,s.jsx)(n.code,{children:"'a'"})," as ",(0,s.jsx)(n.code,{children:"char"}),", ",(0,s.jsx)(n.code,{children:'"hello"'})," as ",(0,s.jsx)(n.code,{children:"const char*"}),"). Terra\u2019s literals are processed at Lua runtime, often requiring Lua constructs (e.g., string indexing, escapes) to match C++ functionality."]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": For character literals, Terra\u2019s workaround (",(0,s.jsx)(n.code,{children:'("a")[0]'}),") returns a numeric byte value (e.g., 97 for ",(0,s.jsx)(n.code,{children:"'a'"}),"), not a distinct ",(0,s.jsx)(n.code,{children:"char"})," type. You could define a Terra function like ",(0,s.jsx)(n.code,{children:"terra char(s : rawstring) : int8 return s[0] end"})," to mimic C++\u2019s ",(0,s.jsx)(n.code,{children:"'a'"})," by converting a string to its first byte."]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Long brackets ",(0,s.jsx)(n.code,{children:"[[...]]"})," could be confused with Terra escapes ",(0,s.jsx)(n.code,{children:"[ ... ]"})," that operate on Terra quoted expressions. In case of ambiguity, use ",(0,s.jsx)(n.code,{children:"escape ... end"})," to apply an escape instead."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"declarations-and-type-constructors",children:"Declarations and Type Constructors"}),"\n",(0,s.jsxs)(n.p,{children:["C++ and Terra both allow variable declarations within functions, but their syntax and type systems differ due to Terra\u2019s integration with Lua. C++ uses static typing with optional type inference (via ",(0,s.jsx)(n.code,{children:"auto"}),"), while Terra combines explicit typing, type inference, and Lua-driven metaprogramming for dynamic code generation. This section compares basic variable declarations in C++ with their Terra equivalents, including Terra\u2019s advanced constructs like ",(0,s.jsx)(n.code,{children:"symbol"})," and ",(0,s.jsx)(n.code,{children:"quote"})," for metaprogramming."]}),"\n",(0,s.jsx)(n.h3,{id:"declaring-variables",children:"Declaring Variables"}),"\n",(0,s.jsxs)(n.p,{children:["C++ declares variables with explicit types or inferred types using ",(0,s.jsx)(n.code,{children:"auto"}),", all resolved statically. Terra offers similar functionality with ",(0,s.jsx)(n.code,{children:"var"}),", supporting both explicit typing and inference, and extends this with Lua metaprogramming for runtime code generation."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void f() {\n    int x;\n    int y = 255;\n    auto z = 255;\n}\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"terra f()\n    var x\n    var y : int = 255\n    var z = 255\nend\n"})})}),(0,s.jsx)(a.c,{title:"Metaprogrammed",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"x = symbol(int)\ny = symbol(int)\nz = symbol(int)\nlocal zdeclare = quote \n    var [z] = 255\nend\nterra f() \n    var [x]\n    var [y]\n    [zdeclare]\n    return x + y + z\nend\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"sizing-integer-types",children:"Sizing integer types:"}),"\n",(0,s.jsxs)(n.p,{children:["C++ provides keywords like ",(0,s.jsx)(n.code,{children:"short"})," and ",(0,s.jsx)(n.code,{children:"long"})," for sized integers, with sizes varying by platform. Terra uses explicit, portable type names (e.g., ",(0,s.jsx)(n.code,{children:"int16"}),", ",(0,s.jsx)(n.code,{children:"int64"}),") for clarity and consistency."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"short s; long l;\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"var s : int16, l : int64\n"})})})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": C++\u2019s ",(0,s.jsx)(n.code,{children:"short"})," and ",(0,s.jsx)(n.code,{children:"long"})," sizes depend on the compiler and architecture, whereas Terra\u2019s ",(0,s.jsx)(n.code,{children:"int16"})," and ",(0,s.jsx)(n.code,{children:"int64"})," guarantee fixed sizes, aligning with modern C++\u2019s ",(0,s.jsx)(n.code,{children:"<cstdint>"})," (e.g., ",(0,s.jsx)(n.code,{children:"int16_t"}),", ",(0,s.jsx)(n.code,{children:"int64_t"}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"non-integer-primitive-types",children:"Non-integer primitive types:"}),"\n",(0,s.jsxs)(n.p,{children:["C++ supports a range of non-integer primitives like ",(0,s.jsx)(n.code,{children:"char"}),", ",(0,s.jsx)(n.code,{children:"float"}),", and ",(0,s.jsx)(n.code,{children:"bool"}),". Terra mirrors these but adapts ",(0,s.jsx)(n.code,{children:"char"})," handling due to Lua\u2019s string-based approach."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"char c = 'a'; \nfloat f; double d; \nbool b;\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"var c : int8 = ('a')[0]\nvar f :float, d : double \nvar b : bool\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"multiple-declarations",children:"Multiple Declarations"}),"\n",(0,s.jsx)(n.p,{children:"C++ allows comma-separated declarations with a shared type, initialized in one line. Terra supports multiple declarations but requires separate type definition for each variable when initialized together."}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int a = 1,b = 2,c = 3;\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"var a : int, b : int, c : int = 1,2,3\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"arrays",children:"Arrays"}),"\n",(0,s.jsxs)(n.p,{children:["C++ initializes arrays with a size or an initializer list, with types and sizes resolved statically at compile time. Terra treats ",(0,s.jsx)(n.code,{children:"array"})," as an expression to populate arrays, requiring explicit type and size definitions that are fixed during just-in-time (JIT) compilation, which occurs right before runtime. The ",(0,s.jsx)(n.code,{children:"arrayof"})," function allows type specification when initializer expressions don\u2019t match the desired type, with all decisions finalized prior to execution."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int a[10];\nint a[]={0,1,2};\nfloat a[]={0,1,2};\nint a[2][3]={ {1,2,3},{4,5,6} }; \n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"var a : int[10];\nvar a : int[3] = array(0,1,2)\nvar a = arrayof([float],0,1,2) \nvar a : (int[3])[2] = array(\n    array(1,2,3),\n    array(4,5,6)\n)\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"pointers-and-references",children:"Pointers and references"}),"\n",(0,s.jsxs)(n.p,{children:["Pointers are essential for low-level programming in C++ and Terra, enabling direct memory manipulation. C++ uses statically typed pointers, including raw pointers, null pointers, and references, each with distinct syntax. Terra adapts these to its type system and Lua environment, declaring pointers with ",(0,s.jsx)(n.code,{children:"&"})," and streamlining dereferencing, often bypassing C++\u2019s reference syntax. This section compares pointer declarations and usage in C++ with Terra equivalents, highlighting how Terra delivers similar functionality differently."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'int* p; \n  \nchar* s ="hello";\n  \nvoid* p = NULL;\n'})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:'var p : &int\n\nvar s : rawstring = "hello"\n\nvar p : &opaque = nil\n'})})})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": C++ uses ",(0,s.jsx)(n.code,{children:"*"})," to declare a pointer, while Terra uses ",(0,s.jsx)(n.code,{children:"&"}),' (read as "address of") before the type, e.g., ',(0,s.jsx)(n.code,{children:"&int"})," for a pointer to an integer. Both are uninitialized by default.\n",(0,s.jsx)(n.strong,{children:"Note"}),": C++\u2019s ",(0,s.jsx)(n.code,{children:"char*"})," points to a null-terminated string. Terra\u2019s ",(0,s.jsx)(n.code,{children:"rawstring"})," (equivalent to ",(0,s.jsx)(n.code,{children:"&int8"}),", a pointer to an 8-bit integer) handles Lua string literals, which are implicitly null-terminated when passed to Terra.\n",(0,s.jsx)(n.strong,{children:"Note"}),": C++\u2019s ",(0,s.jsx)(n.code,{children:"void*"})," is a typeless pointer, set to ",(0,s.jsx)(n.code,{children:"NULL"})," for null. Terra uses ",(0,s.jsx)(n.code,{children:"&opaque"})," as a generic pointer type, with ",(0,s.jsx)(n.code,{children:"nil"})," (Lua\u2019s null value) indicating a null pointer in the Terra context. ",(0,s.jsx)(n.code,{children:"nil"})," integrates with Lua\u2019s type system, ensuring compatibility across contexts.\n",(0,s.jsx)(n.strong,{children:"Note"}),": C++ references (",(0,s.jsx)(n.code,{children:"&"}),") alias an object, accessed with ",(0,s.jsx)(n.code,{children:"."}),", while pointers use ",(0,s.jsx)(n.code,{children:"->"}),". Terra lacks references, using pointers (e.g., ",(0,s.jsx)(n.code,{children:"&Vec3"}),") instead. The ",(0,s.jsx)(n.code,{children:"."})," operator works like C++\u2019s ",(0,s.jsx)(n.code,{children:"->"}),", automatically dereferencing the pointer for member access, reducing syntactic noise."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"typedefs-constants-other",children:"Typedefs, constants, other"}),"\n",(0,s.jsx)(n.p,{children:"Typedefs are just assignments in Lua because Terra types are Lua values"}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"typedef String char*;\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"local String = &int8 \n"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["Terra currently does not have support for ",(0,s.jsx)(n.code,{children:"const"})," local variables."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"const int c = 3;\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"var c = 3\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"enums",children:"Enums"}),"\n",(0,s.jsx)(n.p,{children:"C++ uses enum for static, named constants with integer values. Terra lacks native enums, relying on Lua metaprogramming with tables or macros to achieve similar functionality."}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"enum weekend {SAT,SUN};\nweekend f() {\n    return SAT\n}\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:'local function Enum(...)\n    local t = { type = int }\n    for i,name in ipairs({...}) do\n          -- make 0-based to match C++\n        t[name] = i - 1\n    end\n    return t\nend\nweekend = Enum("SAT","SUN")\nterra f() : weekend.type\n    return weekend.SAT\nend\n'})})})]}),"\n",(0,s.jsx)(n.h2,{id:"global-constant-values",children:"Global (constant) values"}),"\n",(0,s.jsx)(n.p,{children:"C++ defines global constants with const at file scope, ensuring immutability (e.g., const int G = 42). Terra uses Lua variables for mutable globals (e.g., local G = 42), or Terra-specific global(type, expr) for mutable globals with an optional initial expression, and constant(type, expr) for immutable constants requiring both type and value or expression."}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int x = 3;\nconst int y = 3;\nint z[] = { 3,4, 5};\nconst int a[] = { 3,4,5};\n\nvoid f() {\n}\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"x = global(int)\ny = constant(int,3)\nz = global(int,`array(3,4,5))\na = constant(int,`array(3,4,5))\n\nterra f()\nend\n"})})})]}),"\n",(0,s.jsx)(n.p,{children:"Metaprogramming enables you to create sophisticated expressions at compile time that are embedded as constant values in your Terra code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"sin_values = {}\nN = 32\nfor i = 1,N do\n    sin_values[i] = math.sin(2 * math.pi * (i-1)/N))\nend\nsin_table = constant(`arrayof(float,sin_values))\n"})}),"\n",(0,s.jsx)(n.h2,{id:"storage-classes",children:"Storage Classes"}),"\n",(0,s.jsx)(n.p,{children:"C++ uses storage classes (auto, static, extern) to control variable and function scope, lifetime, and linkage, all set at compile time. Terra lacks direct equivalents, relying on Lua\u2019s scoping and global for persistent values. Visibility is managed via terralib.saveobj, while lexical scope can mimic some static behavior using do/end."}),"\n",(0,s.jsx)(n.h3,{id:"global-variables-and-functions",children:"Global Variables and Functions"}),"\n",(0,s.jsx)(n.p,{children:"C++ defines globals with implicit external linkage or static for internal linkage, and extern for cross-file access. Terra uses global(type) for mutable globals, with visibility specified in saveobj."}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int x;\nstatic int y;\n\nstatic void g() {\n    return x + y;\n}\nvoid f() {\n    static int z = 0;\n    return g();\n}\nextern int w;\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:'x = global(int)\ny = global(int)\n\nterra g() \n    return x + y\nend\nterra f()\n    return g()\nend\nterralib.saveobj("out.o", { x = x, f = f}) \n'})})})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": In Terra, only ",(0,s.jsx)(n.code,{children:"x"})," and ",(0,s.jsx)(n.code,{children:"f"})," are exposed as symbols, but ",(0,s.jsx)(n.code,{children:"y"})," and ",(0,s.jsx)(n.code,{children:"g"})," are included internally since they\u2019re used."]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": C++\u2019s ",(0,s.jsx)(n.code,{children:"static"})," limits linkage or persistence; Terra\u2019s ",(0,s.jsx)(n.code,{children:"global"})," is mutable, with ",(0,s.jsx)(n.code,{children:"saveobj"})," controlling exported symbols."]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": C++\u2019s ",(0,s.jsx)(n.code,{children:"extern"})," links globals across files; Terra relies on ",(0,s.jsx)(n.code,{children:"saveobj"})," or external Lua modules for similar access."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"local-static-variables",children:"Local Static Variables"}),"\n",(0,s.jsxs)(n.p,{children:["C++\u2019s ",(0,s.jsx)(n.code,{children:"static"})," in functions creates persistent locals. Terra has no direct equivalent but can use Lua\u2019s ",(0,s.jsx)(n.code,{children:"do/end"})," to lexically scope a ",(0,s.jsx)(n.code,{children:"global"})," for similar effect."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void f() {\n    static int z = 0;\n    return z;\n}\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"do\n    local z = global(int,0)\n    terra f()\n        return z\n    end\nend\n"})})})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Terra uses ",(0,s.jsx)(n.code,{children:"do/end"})," to scope globals, approximating C++\u2019s local ",(0,s.jsx)(n.code,{children:"static"})," without a direct keyword."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"statements",children:"Statements"}),"\n",(0,s.jsx)(n.p,{children:"C++ and Terra use statements to control program flow, but their syntax reflects different influences: C++\u2019s C heritage versus Terra\u2019s Lua foundations. This section compares assignment, declaration, and control structures, highlighting Terra\u2019s adaptations and metaprogramming capability."}),"\n",(0,s.jsx)(n.h3,{id:"assignements",children:"Assignements"}),"\n",(0,s.jsxs)(n.p,{children:["C++ offers compound assignment operators like ",(0,s.jsx)(n.code,{children:"+="}),", while Terra follows Lua\u2019s simpler approach, requiring explicit operations."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"x = y;\nx += y;\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"x = y\nx = x + y -- no += like Lua\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"declarations",children:"Declarations"}),"\n",(0,s.jsxs)(n.p,{children:["C++ declares variables with type-first syntax or ",(0,s.jsx)(n.code,{children:"auto"}),"; Terra uses ",(0,s.jsx)(n.code,{children:"var"})," with optional type annotation."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int x;\nint y = 1;\nauto z = 2;\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"var x : int\nvar y : int = 1\nvar z = 2\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"semi-colons",children:"Semi-Colons"}),"\n",(0,s.jsx)(n.p,{children:"C++ requires semicolons to separate statements; Terra makes them optional, inherited from Lua, though sometimes useful for clarity."}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"x = y; y = z;\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"x = y; y = z;   -- Optional for clarity\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"blocks",children:"Blocks"}),"\n",(0,s.jsxs)(n.p,{children:["C++ uses curly braces for blocks; Terra uses ",(0,s.jsx)(n.code,{children:"do/end"}),"."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'void f() {\n      {\n          printf("hi\\n");\n          printf("hi\\n");\n          printf("hi\\n");\n      }\n  }\n'})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:'terra f()\n    do\n        C.printf("hi\\n")\n        C.printf("hi\\n")\n        C.printf("hi\\n")\n    end\nend\n'})})}),(0,s.jsx)(a.c,{title:"Meta-programmed",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:'local stats = { \n    `C.printf("hi\\n"),\n    `C.printf("hi\\n"),\n    `C.printf("hi\\n")\n}\nterra f()\n    do\n        [stats]\n    end\nend\n'})})})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Terra's metaprogramming with ",(0,s.jsx)(n.code,{children:"[stats]"})," injects quoted statements inside the code block."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"conditionals",children:"Conditionals"}),"\n",(0,s.jsxs)(n.p,{children:["C++ uses parentheses and braces for ",(0,s.jsx)(n.code,{children:"if/else"}),"; Terra adopts Lua\u2019s ",(0,s.jsx)(n.code,{children:"then/end"}),", omitting parentheses."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"if (x) { \n    // <statements> \n}\nelse if (y) { \n    // <statements> \n}\nelse { \n    // <statement> \n}\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"if x then \n    -- <statements>\n\nelseif y then \n    -- <statements>\n\nelse \n    -- <statements> \nend\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"loops",children:"Loops"}),"\n",(0,s.jsxs)(n.p,{children:["C++ provides ",(0,s.jsx)(n.code,{children:"while"}),", ",(0,s.jsx)(n.code,{children:"for"}),", and ",(0,s.jsx)(n.code,{children:"do-while"}),"; Terra uses Lua\u2019s ",(0,s.jsx)(n.code,{children:"while"}),", ",(0,s.jsx)(n.code,{children:"for"}),", and ",(0,s.jsx)(n.code,{children:"repeat/until"}),", with adjusted bounds."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"while(x) {\n    // <statements>\n}\n\nfor(int i = 0; i < 100; i++) {\n    // <statements>\n}\n\ndo { \n    // <statements>\n} while(b);\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"while x do \n    -- <statements>\nend\n\nfor i = 0,100 do  -- note [0,100) bounds\n    -- <statements>\nend \n\nrepeat \n    -- <statements>\nuntil ~b\n"})})})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Terra\u2019s ",(0,s.jsx)(n.code,{children:"for i = 0,100"})," excludes 100; ",(0,s.jsx)(n.code,{children:"~b"})," inverts ",(0,s.jsx)(n.code,{children:"b"})," for ",(0,s.jsx)(n.code,{children:"until"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"switch",children:"Switch"}),"\n",(0,s.jsxs)(n.p,{children:["C++\u2019s ",(0,s.jsx)(n.code,{children:"switch/case"})," uses braces and colons; Terra\u2019s ",(0,s.jsx)(n.code,{children:"switch"})," uses ",(0,s.jsx)(n.code,{children:"then/else"}),", aligning with Lua-like flow."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"switch(x) {\n    case X1: a;\n    case X2: b;\n\n    default: c;\n}\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"switch x do\n    case X1 then a\n    case X2 then b\nelse\n    c\nend\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"control-flow",children:"Control Flow"}),"\n",(0,s.jsxs)(n.p,{children:["C++ and Terra share ",(0,s.jsx)(n.code,{children:"break"})," and ",(0,s.jsx)(n.code,{children:"return"}),". While C++ allows (dead) code after ",(0,s.jsx)(n.code,{children:"break"})," and ",(0,s.jsx)(n.code,{children:"return"}),", Terra throws a compile error."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"break;\nreturn;\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"break\nreturn\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"exceptions",children:"Exceptions"}),"\n",(0,s.jsxs)(n.p,{children:["C++ supports exceptions with ",(0,s.jsx)(n.code,{children:"try/catch"})," for error handling; Terra omits them to maintain simplicity, favoring alternative error strategies. Note that Lua\u2019s ",(0,s.jsx)(n.code,{children:"pcall"})," can handle errors externally."]}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.p,{children:"Functions in C++ and Terra drive program logic, but their definition, declaration, and customization differ. While C++ code generation is static, Terra features powerful abstractions for generating functions dynamically using JIT compilation."}),"\n",(0,s.jsx)(n.h3,{id:"defining-functions",children:"Defining functions"}),"\n",(0,s.jsx)(n.p,{children:"C++ defines functions with a straightforward, type-first syntax and braces. Terra uses terra blocks with Lua-style annotations, supporting metaprogramming for advanced constructs."}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int f(int x, int y) { \n    return x + y; \n}\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"terra f(x : int, y : int) : int \n    return x + y \nend\n"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["Metaprogramming in Terra can unroll operations, like summing arguments, using ",(0,s.jsx)(n.code,{children:"symbol"}),", ",(0,s.jsx)(n.code,{children:"escape"}),", and ",(0,s.jsx)(n.code,{children:"emit quote"})," for dynamic code generation."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"Terra meta-programm",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"local args = {symbol(int),symbol(int)}\nterra f([args])\n    var s = 0\n    escape\n        for _,a in ipairs(args) do\n            emit quote\n              s = s + a\n            end\n        end\n    end\n    return s\nend\n"})})}),(0,s.jsx)(a.c,{title:"Generated code",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"terra f(arg_1 : int, arg_2 : int) : int \n    var s = 0\n    s = s + arg_1\n    s = s + arg_2\n    return s\nend\n"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["C++ uses empty braces for void returns; Terra employs an empty tuple (",(0,s.jsx)(n.code,{children:": {}"}),") to signify no return value."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void f() {\n} // no returns\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"terra f() : {} -- empty tuple means void\nend\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"declaring-functions",children:"Declaring functions"}),"\n",(0,s.jsxs)(n.p,{children:["C++ declares functions with prototypes; Terra uses function types (e.g., ",(0,s.jsx)(n.code,{children:"{args} -> ret"}),"), optionally metaprogrammed with Lua variables."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int f(int x, int y);\n  \nvoid g();\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"terra f :: {int,int} -> int\n--         ~~~~~~~~~~~~~~~~ function type\nterra g :: {} -> {}\n--         ~~    ~~ empty tuple for void/no-args\n"})})}),(0,s.jsx)(a.c,{title:"Meta-programmed",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"local args = {int,int}\nlocal ret  = int\nlocal type = args -> reg\nlocal void = {} -> {}\nterra f :: type\nterra g :: void\n"})})})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Terra\u2019s ",(0,s.jsx)(n.code,{children:"::"})," specifies function signatures; metaprogramming builds types dynamically with Lua."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"function-inlining",children:"Function Inlining"}),"\n",(0,s.jsxs)(n.p,{children:["C++ suggests inlining with ",(0,s.jsx)(n.code,{children:"inline"}),", while Terra\u2019s ",(0,s.jsx)(n.code,{children:"setinlined(true)"})," forces it, akin to ",(0,s.jsx)(n.code,{children:"__always_inline__"}),", for performance-critical code."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"inline void f();\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"f :: {} -> {}\nf:setinlined(true) \n-- actually equivalent to __alwaysinline__\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"operator-overloading",children:"Operator overloading"}),"\n",(0,s.jsx)(n.p,{children:"C++ overloads operators as standalone functions; Terra ties them to a type\u2019s metamethods."}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct T {};\nT operator+(T x, T y) {\n    ...\n}\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"struct T {}\nterra T.metamethods.__add(x : T, y : T)\n    ...\nend\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"function-overloading",children:"Function overloading"}),"\n",(0,s.jsxs)(n.p,{children:["Both languages support overloading, but Terra distinguishes single functions from overloaded sets using ",(0,s.jsx)(n.code,{children:"terralib.overloadedfunction"}),"."]}),"\n",(0,s.jsxs)(a.x,{children:[(0,s.jsx)(a.c,{title:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int max(int a, int b) {\n    return (a > b) ? a : b;\n}\nfloat max(float a, float b) {\n    return (a > b) ? a : b;\n}\n"})})}),(0,s.jsx)(a.c,{title:"Terra",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:'max = terralib.overloadedfunction("max" { \n    terra(a : int, b : int) \n        return terralib.select( a > b, a, b)\n    end,\n    terra(a : float, b : float) \n        return terralib.select( a > b, a, b)\n    end\n})\n'})})})]})]})}function x(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var i=r(6540);const s={},t=i.createContext(s);function a(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);