"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[5503],{4853:(e,a,s)=>{s.d(a,{c:()=>r,x:()=>t});s(6540);var n=s(4848);const t=e=>{let{children:a}=e;return(0,n.jsx)("div",{style:{display:"flex",gap:"1rem",flexWrap:"wrap"},children:a})},r=e=>{let{children:a,title:s}=e;return(0,n.jsxs)("div",{style:{flex:1,minWidth:"300px"},children:[s&&(0,n.jsx)("div",{style:{color:"var(--ifm-font-color-base)",padding:"0.5rem 1rem",borderRadius:"var(--ifm-pre-border-radius, 4px) var(--ifm-pre-border-radius, 4px) 0 0",borderBottom:"none",fontSize:"0.9rem",fontWeight:"bold"},children:s}),(0,n.jsx)("div",{style:{marginTop:s?"0":"inherit",borderRadius:s?"0 0 var(--ifm-pre-border-radius, 4px) var(--ifm-pre-border-radius, 4px)":"var(--ifm-pre-border-radius, 4px)",overflow:"hidden"},children:a})]})}},8453:(e,a,s)=>{s.d(a,{R:()=>i,x:()=>l});var n=s(6540);const t={},r=n.createContext(t);function i(e){const a=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),n.createElement(r.Provider,{value:a},e.children)}},9833:(e,a,s)=>{s.r(a),s.d(a,{assets:()=>c,contentTitle:()=>m,default:()=>p,frontMatter:()=>l,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"features/multistage-programming","title":"Multistage programming","description":"Multistage programming is a cornerstone of Terra\'s design, enabling developers to write code that generates and specializes other code at compile-time. By treating Terra\'s functions, types, variables, and expressions as first-class values in Lua, multistage programming allows for dynamic code construction, optimization, and specialization. This paradigm, rooted in the interplay between Lua\'s flexibility and Terra\'s high-performance compilation, empowers developers to create efficient, adaptive programs with minimal boilerplate.","source":"@site/docs/features/multistage-programming.mdx","sourceDirName":"features","slug":"/features/multistage-programming","permalink":"/terra-website/docs/features/multistage-programming","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/features/multistage-programming.mdx","tags":[],"version":"current","frontMatter":{"id":"multistage-programming","title":"Multistage programming"}}');var t=s(4848),r=s(8453),i=s(4853);const l={id:"multistage-programming",title:"Multistage programming"},m="Multistage programming in Terra",c={},o=[{value:"Dynamic Code Generation",id:"dynamic-code-generation",level:2},{value:"Implementing Compiler Features as Libraries",id:"implementing-compiler-features-as-libraries",level:2}];function d(e){const a={annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,r.R)(),...e.components},{Details:s}=a;return s||function(e,a){throw new Error("Expected "+(a?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.header,{children:(0,t.jsx)(a.h1,{id:"multistage-programming-in-terra",children:"Multistage programming in Terra"})}),"\n",(0,t.jsx)(a.p,{children:"Multistage programming is a cornerstone of Terra's design, enabling developers to write code that generates and specializes other code at compile-time. By treating Terra's functions, types, variables, and expressions as first-class values in Lua, multistage programming allows for dynamic code construction, optimization, and specialization. This paradigm, rooted in the interplay between Lua's flexibility and Terra's high-performance compilation, empowers developers to create efficient, adaptive programs with minimal boilerplate."}),"\n",(0,t.jsx)(a.h2,{id:"dynamic-code-generation",children:"Dynamic Code Generation"}),"\n",(0,t.jsx)(a.p,{children:'The design of Terra stems from the insight that C/C++ effectively comprises multiple "languages": a core language of operators, control flow, and function calls, surrounded by a fragmented meta-language including the preprocessor, templating system, and struct definitions. While C++ templates are Turing-complete and have enabled optimized libraries like Eigen, they are notoriously cumbersome in practice.'}),"\n",(0,t.jsx)(a.p,{children:"Terra embraces and extends this trend by replacing C/C++'s ad-hoc meta-language with a full-fledged programming language: Lua. This pairing of a low-level systems language with a high-level scripting language unlocks capabilities beyond traditional systems. Unlike C/C++, Terra code can be JIT-compiled and executed interleaved with Lua, simplifying the creation of libraries that rely on runtime code generation."}),"\n",(0,t.jsx)(a.p,{children:"As a result, features from other languages\u2014such as conditional compilation and templating\u2014emerge organically from Lua's metaprogramming of Terra. For example, templated types, akin to C++ templates but far more flexible, arise through Lua's dynamic code generation, supporting parameterized structs and functions without rigid syntax. Arbitrary compile-time computations, like producing optimized kernels based on runtime parameters or domain-specific abstractions, become simple Lua scripts that seamlessly integrate high-performance Terra code with expressive metaprogramming."}),"\n",(0,t.jsx)(a.p,{children:"Multistage programming further empowers Terra to dynamically generate code tailored to specific scenarios, such as functions optimized for input sizes, hardware targets, or constraints. This is invaluable for tasks like loop unrolling, constant folding, or SIMD vectorization, all orchestrated via Lua for efficient, adaptive execution."}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Example: Conditional compilation "}),(0,t.jsx)(a.p,{children:"Conditional compilation is done with control-flow that determines what code is defined."}),(0,t.jsxs)(i.x,{children:[(0,t.jsx)(i.c,{title:"Terra",children:(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-terra",children:"if iswindows() then\n    terra waitatend()\n        C.getchar()\n    end\nelse\n    terra waitatend() end\nend\n"})})}),(0,t.jsx)(i.c,{title:"C++",children:(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-cpp",children:"#ifdef _WIN32\n    void waitatend() { \n        getchar(); \n    }\n#else\n    void waitatend() {}\n#endif\n"})})})]})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Example: Templated types"}),(0,t.jsx)(a.p,{children:"Templates become Lua functions that take a terra type T and use it to generate new types and code."}),(0,t.jsxs)(i.x,{children:[(0,t.jsx)(i.c,{title:"Terra",children:(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-terra",children:"function Array(T)\n    struct Array {\n        N : int\n        data : &T\n    }\n    terra Array:get(i : int)\n        return self.data[i]\n    end\n    return Array\nend\n\nFloatArray = Array(float)\n"})})}),(0,t.jsx)(i.c,{title:"C++",children:(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-cpp",children:"template<class T>\nstruct Array {\n    int N;\n    T* data;\n\n    T get(int i) {\n        return data[i];\n    }\n\n};\n\ntypedef Array<float> FloatArray;\n"})})})]})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Example: loop unrolling in polynomial evaluation"}),(0,t.jsxs)(a.p,{children:["We explore loop unrolling in Terra for evaluating a cubic polynomial ",(0,t.jsxs)(a.span,{className:"katex",children:[(0,t.jsx)(a.span,{className:"katex-mathml",children:(0,t.jsx)(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(a.semantics,{children:[(0,t.jsxs)(a.mrow,{children:[(0,t.jsx)(a.mi,{children:"p"}),(0,t.jsx)(a.mo,{stretchy:"false",children:"("}),(0,t.jsx)(a.mi,{children:"x"}),(0,t.jsx)(a.mo,{stretchy:"false",children:")"}),(0,t.jsx)(a.mo,{children:"="}),(0,t.jsx)(a.mi,{children:"a"}),(0,t.jsx)(a.mo,{children:"+"}),(0,t.jsx)(a.mi,{children:"b"}),(0,t.jsx)(a.mo,{children:"\u22c5"}),(0,t.jsx)(a.mi,{children:"x"}),(0,t.jsx)(a.mo,{children:"+"}),(0,t.jsx)(a.mi,{children:"c"}),(0,t.jsx)(a.mo,{children:"\u22c5"}),(0,t.jsxs)(a.msup,{children:[(0,t.jsx)(a.mi,{children:"x"}),(0,t.jsx)(a.mn,{children:"2"})]}),(0,t.jsx)(a.mo,{children:"+"}),(0,t.jsx)(a.mi,{children:"d"}),(0,t.jsx)(a.mo,{children:"\u22c5"}),(0,t.jsxs)(a.msup,{children:[(0,t.jsx)(a.mi,{children:"x"}),(0,t.jsx)(a.mn,{children:"3"})]})]}),(0,t.jsx)(a.annotation,{encoding:"application/x-tex",children:"p(x) = a + b \\cdot x + c \\cdot x^2 + d \\cdot x^3"})]})})}),(0,t.jsxs)(a.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"p"}),(0,t.jsx)(a.span,{className:"mopen",children:"("}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"x"}),(0,t.jsx)(a.span,{className:"mclose",children:")"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(a.span,{className:"mrel",children:"="}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"a"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"+"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.6944em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"b"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"\u22c5"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"x"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"+"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.4445em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"c"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"\u22c5"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.8974em",verticalAlign:"-0.0833em"}}),(0,t.jsxs)(a.span,{className:"mord",children:[(0,t.jsx)(a.span,{className:"mord mathnormal",children:"x"}),(0,t.jsx)(a.span,{className:"msupsub",children:(0,t.jsx)(a.span,{className:"vlist-t",children:(0,t.jsx)(a.span,{className:"vlist-r",children:(0,t.jsx)(a.span,{className:"vlist",style:{height:"0.8141em"},children:(0,t.jsxs)(a.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,t.jsx)(a.span,{className:"pstrut",style:{height:"2.7em"}}),(0,t.jsx)(a.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsx)(a.span,{className:"mord mtight",children:"2"})})]})})})})})]}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"+"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.6944em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"d"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"\u22c5"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.8141em"}}),(0,t.jsxs)(a.span,{className:"mord",children:[(0,t.jsx)(a.span,{className:"mord mathnormal",children:"x"}),(0,t.jsx)(a.span,{className:"msupsub",children:(0,t.jsx)(a.span,{className:"vlist-t",children:(0,t.jsx)(a.span,{className:"vlist-r",children:(0,t.jsx)(a.span,{className:"vlist",style:{height:"0.8141em"},children:(0,t.jsxs)(a.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,t.jsx)(a.span,{className:"pstrut",style:{height:"2.7em"}}),(0,t.jsx)(a.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsx)(a.span,{className:"mord mtight",children:"3"})})]})})})})})]})]})]})]}),", where coefficients are stored in a struct array (",(0,t.jsx)(a.code,{children:"coeffs[0] = a"}),", ",(0,t.jsx)(a.code,{children:"coeffs[1] = b"}),",  ",(0,t.jsx)(a.code,{children:"coeffs[2] = c"}),",  ",(0,t.jsx)(a.code,{children:"coeffs[3] = d"}),".). Horner's method rewrites the polynomial as ",(0,t.jsxs)(a.span,{className:"katex",children:[(0,t.jsx)(a.span,{className:"katex-mathml",children:(0,t.jsx)(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(a.semantics,{children:[(0,t.jsxs)(a.mrow,{children:[(0,t.jsx)(a.mi,{children:"a"}),(0,t.jsx)(a.mo,{children:"+"}),(0,t.jsx)(a.mi,{children:"x"}),(0,t.jsx)(a.mo,{children:"\u22c5"}),(0,t.jsx)(a.mo,{stretchy:"false",children:"("}),(0,t.jsx)(a.mi,{children:"b"}),(0,t.jsx)(a.mo,{children:"+"}),(0,t.jsx)(a.mi,{children:"x"}),(0,t.jsx)(a.mo,{children:"\u22c5"}),(0,t.jsx)(a.mo,{stretchy:"false",children:"("}),(0,t.jsx)(a.mi,{children:"c"}),(0,t.jsx)(a.mo,{children:"+"}),(0,t.jsx)(a.mi,{children:"x"}),(0,t.jsx)(a.mo,{children:"\u22c5"}),(0,t.jsx)(a.mi,{children:"d"}),(0,t.jsx)(a.mo,{stretchy:"false",children:")"}),(0,t.jsx)(a.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(a.annotation,{encoding:"application/x-tex",children:"a + x \\cdot (b + x \\cdot (c + x \\cdot d))"})]})})}),(0,t.jsxs)(a.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"a"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"+"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.4445em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"x"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"\u22c5"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(a.span,{className:"mopen",children:"("}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"b"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"+"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.4445em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"x"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"\u22c5"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(a.span,{className:"mopen",children:"("}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"c"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"+"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.4445em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"x"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"\u22c5"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"d"}),(0,t.jsx)(a.span,{className:"mclose",children:"))"})]})]})]})," to minimize multiplications and additions, improving numerical stability and performance."]}),(0,t.jsx)(a.p,{children:"Terra's metaprogramming capabilities allow us to unroll loops at compile time, generating explicit, optimized code without runtime overhead. The following code defines a generic, templated Polynomial evaluator supporting float or double types. It uses loop unrolling in the eval method to produce efficient, branch-free code."}),(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/tutorial-poly-standard.t start=poly_start end=poly_end",children:"--`Polynomial` type templated by the element type `T`, equal to `float` or `double`, and the and the polynomial order `N`\n--`terralib.memoize` caches the function output for each `(T, N)`, avoiding recompilation.\nlocal Polynomial = terralib.memoize(function(T, N)\n\n    --Check input\n    assert(T == float or T == double, \"CompileError: expected a 'float' or 'double' type.\")\n    assert(type(N) == \"number\" and N>0 and N%1==0, \"CompileError: expected a positive integer.\")\n\n    --Define struct type. The coefficients are stored in an array of length N\n    local struct poly{\n        coeffs : T[N]\n    }\n\n    --Polynomial evaluation using Horner's method. Here the loop is unrolled at compile-time\n    terra poly:eval(x : T)\n        var y = self.coeffs[N-1] -- Start with the highest-degree coefficient\n        escape -- Enter Lua metaprogramming mode to generate code at compile-time\n            for i=N-2,0,-1 do -- Iterate over remaining coefficients in reverse order\n                emit quote -- Emit explicit Terra statements for unrolling\n                    y = x * y + self.coeffs[i] -- Nested multiply-add\n                end\n            end\n        end\n        return y\n    end\n\n    -- Convenience method enabling function-like evaluation of a 'poly' object (e.g., p(x))\n    poly.metamethods.__apply = macro(function(self, x)\n        return `self:eval(x) -- Macro expands to eval call at compile time\n    end)\n\n    return poly -- Return the templated struct type\nend)\n"})}),(0,t.jsx)(a.p,{children:"To create a cubic polynomial type with float coefficients:"}),(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-terra",children:"local poly = Polynomial(float, 4) -- Generates and caches the type\n"})}),(0,t.jsxs)(a.p,{children:["Inspect the unrolled eval method using ",(0,t.jsx)(a.code,{children:":printpretty()"})," to see the expanded Terra code:"]}),(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"tutorial-poly.t:31:     terra poly.eval(self : &poly,x : float) : float\ntutorial-poly.t:32:         var y : float = [&float]((@self).coeffs)[3] -- c\ntutorial-poly.t:36:         y = x * y + [&float]((@self).coeffs)[2]     -- x*d + c\ntutorial-poly.t:36:         y = x * y + [&float]((@self).coeffs)[1]     -- x*(x*d + c) + b\ntutorial-poly.t:36:         y = x * y + [&float]((@self).coeffs)[0]     -- x*(x*(x*d + c) + b) + a\ntutorial-poly.t:40:         return y\ntutorial-poly.t:31:     end\n"})}),(0,t.jsx)(a.p,{children:"This shows the loop fully unrolled into sequential multiply-adds, ready for further optimization by the compiler."}),(0,t.jsxs)(a.p,{children:["View the generated assembly with ",(0,t.jsx)(a.code,{children:":disas()"})," (with -O3 on an AMD CPU):"]}),(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"assembly for function at address 0x722b5a3bb000\n0x722b5a3bb000(+0):             vmulsd  xmm1, xmm0, qword ptr [rdi + 24]\n0x722b5a3bb005(+5):             vaddsd  xmm1, xmm1, qword ptr [rdi + 16]\n0x722b5a3bb00a(+10):            vmulsd  xmm1, xmm1, xmm0\n0x722b5a3bb00e(+14):            vaddsd  xmm1, xmm1, qword ptr [rdi + 8]\n0x722b5a3bb013(+19):            vmulsd  xmm0, xmm1, xmm0\n0x722b5a3bb017(+23):            vaddsd  xmm0, xmm0, qword ptr [rdi]\n0x722b5a3bb01b(+27):            ret\n"})}),(0,t.jsxs)(a.p,{children:["This code is already quite efficient with 7 instructions (3 multiplies, 3 adds, 1 return) and 3 registers (an input/output register ",(0,t.jsx)(a.code,{children:"xmm0"}),", a register ",(0,t.jsx)(a.code,{children:"xmm1"})," to hold a temporary, and a general purpose register ",(0,t.jsx)(a.code,{children:"rdi"})," to point to the coefficient array)."]})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Example: Optimizing with LLVM Intrinsics for fused-multiply-addition (FMA) "}),(0,t.jsx)(a.p,{children:"We can further optimize the code of the previous example by fusing the addition and multiplication into one operation. The intrinsic (llvm.fma.f64 or llvm.fma.f32) ensures the compiler emits hardware FMA instructions (e.g., vfmadd213sd), reducing instruction count, latency, and rounding errors."}),(0,t.jsx)(a.p,{children:"Here's the optimized code integrated into the Polynomial factory (replace the original eval method and add the intrinsic definition):"}),(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/tutorial-poly-optimized.t start=polyeval_start end=polyeval_end",children:'-- Intrinsic for fused-multiply-add (axpy form: x*y + z)\nlocal axpy = terralib.intrinsic(T == float and "llvm.fma.f32" or "llvm.fma.f64", {T, T, T} -> T)\n\n--Polynomial evaluation using Horner\'s method. Here the loop is unrolled at compile-time\nterra poly:eval(x : T)\n    var y = self.coeffs[N-1] -- Start with highest coefficient\n    escape\n        for i=N-2,0,-1 do\n            emit quote\n                y = axpy(x, y, self.coeffs[i]) -- Fused: x * y + coeffs[i]\n            end\n        end\n    end\n    return y\nend\n'})}),(0,t.jsxs)(a.p,{children:["The Terra intrinsic declaration maps directly to LLVM's FMA operation, selecting ",(0,t.jsx)(a.code,{children:"llvm.fma.f32"})," for floats or ",(0,t.jsx)(a.code,{children:"llvm.fma.f64"})," for doubles based on type ",(0,t.jsx)(a.code,{children:"T"}),". It takes three ",(0,t.jsx)(a.code,{children:"T"})," arguments (x, y, z) and returns ",(0,t.jsx)(a.code,{children:"T"}),", computing ",(0,t.jsxs)(a.span,{className:"katex",children:[(0,t.jsx)(a.span,{className:"katex-mathml",children:(0,t.jsx)(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(a.semantics,{children:[(0,t.jsxs)(a.mrow,{children:[(0,t.jsx)(a.mi,{children:"x"}),(0,t.jsx)(a.mo,{children:"\u22c5"}),(0,t.jsx)(a.mi,{children:"y"}),(0,t.jsx)(a.mo,{children:"+"}),(0,t.jsx)(a.mi,{children:"z"})]}),(0,t.jsx)(a.annotation,{encoding:"application/x-tex",children:"x \\cdot y + z"})]})})}),(0,t.jsxs)(a.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.4445em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",children:"x"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"\u22c5"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.7778em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(a.span,{className:"mbin",children:"+"}),(0,t.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(a.span,{className:"base",children:[(0,t.jsx)(a.span,{className:"strut",style:{height:"0.4306em"}}),(0,t.jsx)(a.span,{className:"mord mathnormal",style:{marginRight:"0.04398em"},children:"z"})]})]})]}),"\u2014perfect for Horner's nesting. This results in the following assembly with 5 instructions and 3 fused-multiply-adds."]}),(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"assembly for function at address 0x736c9cc8a000\n0x736c9cc8a000(+0):             vmovsd  xmm1, qword ptr [rdi + 24]\n0x736c9cc8a005(+5):             vfmadd213sd     xmm1, xmm0, qword ptr [rdi + 16]\n0x736c9cc8a00b(+11):            vfmadd213sd     xmm1, xmm0, qword ptr [rdi + 8]\n0x736c9cc8a011(+17):            vfmadd213sd     xmm0, xmm1, qword ptr [rdi]\n0x736c9cc8a016(+22):            ret\n"})})]}),"\n",(0,t.jsx)(a.h2,{id:"implementing-compiler-features-as-libraries",children:"Implementing Compiler Features as Libraries"}),"\n",(0,t.jsx)(a.p,{children:"Multistage programming empowers users to implement language extensions\u2014typically reserved for compiler developers\u2014as simple Lua libraries. This capability stems from Terra's design: Lua serves as a staging language to generate and specialize Terra code dynamically at compile time. Features like lambdas, generics, or custom optimizations can be built modularly without altering the core compiler, enabling rapid prototyping, better portability, and user-defined DSLs. This library-based approach democratizes language design, shifting complexity from monolithic compilers to reusable modules, and reduces overhead by generating efficient, specialized code on-the-fly."}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Example: Implementing Lambdas as a Library in Terra "}),(0,t.jsx)(a.p,{children:"In traditional languages, lambdas (anonymous functions with captures) require compiler support for closure creation, variable capturing, and invocation. In Terra, multistage programming allows this to be implemented concisely as a Lua library using macros and structs. The following code creates function objects that wrap a Terra function, capture variables in a struct, and overload the apply metamethod for invocation. It's only a few lines, demonstrating the power of multistage programming to implement compiler features."}),(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/liblambda.t start=lambda_new_start end=lambda_new_end",children:'-- Helper function to validate the capture expression\n-- Ensures the capture is a struct with named entries (e.g., {x = xvalue, y = yvalue})\nlocal ckecklambdaexpr = function(expr)\n    if not (expr.tree and expr.tree.type and expr.tree.type:isstruct()) then\n        error("Not a valid capture. " ..\n              "The capture syntax uses named arguments as follows: " ..\n              "{x = xvalue, ...}.", 2)\n    end\nend\n\n-- Factory function to create a lambda type from a function and capture object\n-- Wraps the function in a struct, overloads __apply for invocation, and handles type info\nlocal makelambda = function(fun, lambdaobj)\n    -- Validate the capture object\n    ckecklambdaexpr(lambdaobj)\n    local lambdatype = lambdaobj:gettype()\n\n    -- Overload the call operator (__apply) to make the struct callable\n    -- Uses memoize to cache the returned expression; unpacks captured variables and applies the function\n    lambdatype.metamethods.__apply = macro(terralib.memoize(function(self, ...)\n        local args = terralib.newlist{...}\n        return `fun([args], unpackstruct(self)) -- Apply fun with args and unpacked captures\n    end))\n    \n    -- Infer and add return type/parameter info from the wrapped function if possible\n    local funtype = fun:gettype()\n    if funtype:ispointertofunction() then\n        lambdatype.returntype = funtype.type.returntype\n        local nargs = #funtype.type.parameters - #lambdatype.entries\n        lambdatype.parameters = funtype.type.parameters:filteri(function(i,v) return i <= nargs end)\n    end\n\n    return lambdaobj\nend \n\n-- Macro to create a new lambda: wraps fun with optional captures (defaults to empty struct)\nlocal new = macro(function(fun, capture)\n    local lambda = makelambda(fun, capture or quote var c : terralib.types.newstruct() in c end)\n    return `lambda\nend)\n\nreturn {\n    new = new\n}\n'})}),(0,t.jsx)(a.p,{children:"By loading this small library you can define and use lambda's as follows:"}),(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/tutorial-lambda.t start=tutorial_lambda_start end=tutorial_lambda_end",children:'local lambda = require("liblambda")\n\nterra example1(y : int)\n    var p = lambda.new([terra(x : int, y : int) return 2*x + y end], {y = y})\n    return p(3)\nend\nprint("value returned by lambda is: " .. tostring(example1(2)))\n\n\nterra add(a : double, b : double) : double return a + b end\n\nterra example2(v : int)\n    var captured = {value = 5.0}\n    var p = lambda.new(add, captured)  -- Lambda capturing \'value\' as first arg\n    return p(v)\nend\nprint("value returned by lambda is: " .. tostring(example2(3.0)))\n'})})]})]})}function p(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);