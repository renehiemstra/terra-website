"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[1592],{5676:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"resource-management/comparison","title":"Comparisons with C++ and Rust","description":"Terra\u2019s resource management system harmonizes C++\u2019s control with Rust\u2019s ownership principles, emphasizing both simplicity and efficiency. Compared to C++, Terra forgoes certain flexibilities, such as constructors, in favor of a concise Rule of Three (dtor, copy, move) characterized by simple and safe rules. It enhances performance over C++ for R-values by consistently employing a bitwise copy (memcpy), avoiding C++\u2019s potential for implicit copying or dependence on optimizations. For L-values, Terra invokes a move method to ensure explicit resource transfer, with efficient defaults delivering predictable performance.","source":"@site/docs/resource-management/comparison.md","sourceDirName":"resource-management","slug":"/resource-management/comparison","permalink":"/terra-website/docs/resource-management/comparison","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/resource-management/comparison.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Ownership model","permalink":"/terra-website/docs/resource-management/ownership-model"},"next":{"title":"Tutorial - Move semantics in Terra","permalink":"/terra-website/docs/resource-management/tutorial/move-semantics"}}');var n=r(4848),o=r(8453);const t={},a="Comparisons with C++ and Rust",c={},l=[{value:"Terra vs. C++",id:"terra-vs-c",level:2},{value:"Similarities",id:"similarities",level:3},{value:"Differences",id:"differences",level:3},{value:"Terra vs. Rust",id:"terra-vs-rust",level:2},{value:"Similarities",id:"similarities-1",level:3},{value:"Differences",id:"differences-1",level:3}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"comparisons-with-c-and-rust",children:"Comparisons with C++ and Rust"})}),"\n",(0,n.jsxs)(s.p,{children:["Terra\u2019s resource management system harmonizes C++\u2019s control with Rust\u2019s ownership principles, emphasizing both simplicity and efficiency. Compared to C++, Terra forgoes certain flexibilities, such as constructors, in favor of a concise Rule of Three (",(0,n.jsx)(s.code,{children:"__dtor"}),", ",(0,n.jsx)(s.code,{children:"__copy"}),", ",(0,n.jsx)(s.code,{children:"__move"}),") characterized by simple and safe rules. It enhances performance over C++ for R-values by consistently employing a bitwise copy (memcpy), avoiding C++\u2019s potential for implicit copying or dependence on optimizations. For L-values, Terra invokes a ",(0,n.jsx)(s.code,{children:"__move"})," method to ensure explicit resource transfer, with efficient defaults delivering predictable performance."]}),"\n",(0,n.jsxs)(s.p,{children:["Relative to Rust, Terra offers increased flexibility at the expense of some safety assurances. While Rust employs a uniform bitwise copy for moving both L-values and R-values \u2014 unless the Copy trait triggers copying \u2014 Terra distinguishes between these contexts: R-values are moved via memcpy, while L-values utilize a customizable ",(0,n.jsx)(s.code,{children:"__move"})," method. This permits Terra to adapt L-value resource transfers, a capability absent in Rust\u2019s fixed move semantics. Both languages emphasize efficient defaults, yet Terra\u2019s consistent R-value moves avoid the copying that Rust applies to Copy types. Upcoming safety features, like compile-time initialization checks and read-only borrowing with ",(0,n.jsx)(s.code,{children:"const&"}),", will boost Terra\u2019s safety, getting closer to Rust\u2019s strictness while keeping its flexible design."]}),"\n",(0,n.jsx)(s.h2,{id:"terra-vs-c",children:"Terra vs. C++"}),"\n",(0,n.jsx)(s.h3,{id:"similarities",children:"Similarities"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Explicit memory management"}),": Both leverage explicit memory management (Terra via C\u2019s ",(0,n.jsx)(s.code,{children:"malloc"}),"/",(0,n.jsx)(s.code,{children:"free"}),", C++ via ",(0,n.jsx)(s.code,{children:"new"}),"/",(0,n.jsx)(s.code,{children:"delete"}),")."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Assignment Operators"}),": Terra\u2019s ",(0,n.jsx)(s.code,{children:"__copy"})," and ",(0,n.jsx)(s.code,{children:"__move"})," echo C++\u2019s copy / move assignment operators (",(0,n.jsx)(s.code,{children:"operator="}),")."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Read-Only References"}),": Planned ",(0,n.jsx)(s.code,{children:"const&"})," mirrors C++\u2019s ",(0,n.jsx)(s.code,{children:"const T&"})," for read-only access."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"differences",children:"Differences"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Simplicity"}),": Terra's rule of three (",(0,n.jsx)(s.code,{children:"__dtor"}),", ",(0,n.jsx)(s.code,{children:"__copy"}),", ",(0,n.jsx)(s.code,{children:"__move"}),") reduces boilerplate by omitting constructors, while C++'s rule of five requires destructor, copy/move constructors, and copy/move assignment."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"R-Value Handling"}),": Terra always moves R-values with memcpy, enhancing performance over C++\u2019s potential copying or optimization reliance."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"L-Value Handling"}),": Terra invokes ",(0,n.jsx)(s.code,{children:"__move"})," for L-values by default, ensuring explicit transfer, whereas C++ may copy unless move semantics are applied."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Defaults"}),": Terra auto-generates ",(0,n.jsx)(s.code,{children:"__move"})," for managed types and ",(0,n.jsx)(s.code,{children:"__copy"})," for aggregrate copyable manged types; C++ defaults to shallow copies unless overridden."]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"terra-vs-rust",children:"Terra vs. Rust"}),"\n",(0,n.jsx)(s.h3,{id:"similarities-1",children:"Similarities"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Single Ownership"}),": Both ensure one owner per resource, preventing data races."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Move-by-Default"}),": Terra and Rust move resources unless copying is opted in (",(0,n.jsx)(s.code,{children:"__copy"})," vs. ",(0,n.jsx)(s.code,{children:"Copy"})," trait)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Efficient Defaults"}),": Both prioritize performance, with Terra and Rust moving non-copyable types efficiently."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"differences-1",children:"Differences"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Move Customization"}),": Terra\u2019s ",(0,n.jsx)(s.code,{children:"__move"})," is customizable (or deletable), while Rust\u2019s moves are implicit and fixed (memcpy)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Copy Customization"}),": Terra\u2019s ",(0,n.jsx)(s.code,{children:"__copy"})," allows custom logic for L-values; Rust separates Copy (bitwise) and Clone (custom), applying Copy implicitly."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"R-Value Semantics"}),": Terra moves all R-values via memcpy; Rust copies R-values of Copy types, moving only non-Copy types."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"L-Value Semantics"}),": Terra calls ",(0,n.jsx)(s.code,{children:"__move"})," for L-values; Rust uses memcpy for all moves unless Copy applies copying."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Safety"}),": Rust\u2019s borrow checker offers stricter safety; Terra relies on planned features like initialization tracking and ",(0,n.jsx)(s.code,{children:"const&"})," that will bring it closer to Rust's safety features."]}),"\n"]})]})}function m(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,s,r)=>{r.d(s,{R:()=>t,x:()=>a});var i=r(6540);const n={},o=i.createContext(n);function t(e){const s=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:t(e.components),i.createElement(o.Provider,{value:s},e.children)}}}]);