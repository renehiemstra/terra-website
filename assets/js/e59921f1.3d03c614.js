"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[4803],{7207:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"core-language/resource-management/tutorial/move-semantics","title":"Tutorial - Move semantics in Terra","description":"In this tutorial, we explore Terra\u2019s resource management system through the lens of move semantics\u2014its default approach to handling resources. We\u2019ll implement basic data structures to demonstrate how managed types integrate seamlessly, showcasing the power and simplicity of ownership transfer in Terra.","source":"@site/docs/core-language/resource-management/tutorial/move-semantics.md","sourceDirName":"core-language/resource-management/tutorial","slug":"/core-language/resource-management/tutorial/move-semantics","permalink":"/terra-website/docs/core-language/resource-management/tutorial/move-semantics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/core-language/resource-management/tutorial/move-semantics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Comparisons with C++ and Rust","permalink":"/terra-website/docs/core-language/resource-management/comparison"},"next":{"title":"Tutorial - Value semantics","permalink":"/terra-website/docs/core-language/resource-management/tutorial/value-semantics"}}');var r=t(4848),s=t(8453);const o={},i="Tutorial - Move semantics in Terra",c={},l=[{value:"Implementation of a dynamic stack",id:"implementation-of-a-dynamic-stack",level:2},{value:"Implementation of a dynamic vector",id:"implementation-of-a-dynamic-vector",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"tutorial---move-semantics-in-terra",children:"Tutorial - Move semantics in Terra"})}),"\n",(0,r.jsx)(n.p,{children:"In this tutorial, we explore Terra\u2019s resource management system through the lens of move semantics\u2014its default approach to handling resources. We\u2019ll implement basic data structures to demonstrate how managed types integrate seamlessly, showcasing the power and simplicity of ownership transfer in Terra."}),"\n",(0,r.jsx)(n.p,{children:"We\u2019ll build the following managed types:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Dynamic Stack: A dynamically sized container that allocates memory on the heap. It offers element access, push and pop methods, and automatically reallocates resources when capacity is exceeded."}),"\n",(0,r.jsx)(n.li,{children:"Dynamic Vector: A fixed-size container that allocates a single chunk of heap memory without reallocation. It provides element access and supports a user-defined cast from a Dynamic Stack for resource transfer."}),"\n",(0,r.jsx)(n.li,{children:"Quadrature Rule: An aggregate type combining two Dynamic Vectors, with element access to its paired components."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Our focus is on Terra\u2019s move semantics: how resources are transferred efficiently by default, ensuring single ownership without unnecessary copying. Let\u2019s dive in and see these concepts in action!"}),"\n",(0,r.jsx)(n.h2,{id:"implementation-of-a-dynamic-stack",children:"Implementation of a dynamic stack"}),"\n",(0,r.jsxs)(n.p,{children:["Let\u2019s kick off with DynamicStack, a managed type that exemplifies Terra\u2019s move semantics. This dynamic, heap-allocated container supports element access via ",(0,r.jsx)(n.code,{children:"stack(i)"}),", along with push and pop methods. It automatically reallocates when capacity is exceeded. By defining only ",(0,r.jsx)(n.code,{children:"__init"})," and ",(0,r.jsx)(n.code,{children:"__dtor"}),", we leverage Terra\u2019s auto-generated ",(0,r.jsx)(n.code,{children:"__move"})," for efficient resource transfers, enforcing move-only behavior without copying\u2014a perfect entry point to understanding Terra\u2019s default ownership and resource management."]}),"\n",(0,r.jsx)(n.p,{children:"Some general remarks are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Library Support: Load ",(0,r.jsx)(n.code,{children:"terralibext"})," for memory management and C\u2019s ",(0,r.jsx)(n.code,{children:"stdlib"})," via    ",(0,r.jsx)(n.code,{children:'terralib.includec("stdlib.h")'}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["The Lua function ",(0,r.jsx)(n.code,{children:"terralib.memoize"})," enables caching of the definition ",(0,r.jsx)(n.code,{children:"DynamicStack(T)"})," for element type ",(0,r.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Static Methods:",(0,r.jsx)(n.code,{children:"Stack.metamethods.__getmethod"})," allows ",(0,r.jsx)(n.code,{children:"Stack.new"})," calls, simplifying static method access."]}),"\n",(0,r.jsxs)(n.li,{children:["Element Access: ",(0,r.jsx)(n.code,{children:"Stack.metamethods.__apply"}),", a macro, enables ",(0,r.jsx)(n.code,{children:"stack(i)"})," for both get/set access."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Memory Management Notes"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["C Integration: Uses ",(0,r.jsx)(n.code,{children:"malloc"}),", ",(0,r.jsx)(n.code,{children:"realloc"}),", and ",(0,r.jsx)(n.code,{children:"free"})," from C\u2019s ",(0,r.jsx)(n.code,{children:"stdlib"})," for heap management."]}),"\n",(0,r.jsxs)(n.li,{children:["Move Semantics: ",(0,r.jsx)(n.code,{children:"push"})," and ",(0,r.jsx)(n.code,{children:"pop"})," use ",(0,r.jsx)(n.code,{children:"__move__"})," to transfer resources via a type\u2019s ",(0,r.jsx)(n.code,{children:"__move"})," method (if defined), avoiding copies."]}),"\n",(0,r.jsxs)(n.li,{children:["Implementation: Implements ",(0,r.jsx)(n.code,{children:"__init"})," and ",(0,r.jsx)(n.code,{children:"__dtor"}),"; ",(0,r.jsx)(n.code,{children:"__move"})," is auto-generated, making the stack movable but not copyable by default."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-terra",children:'require "terralibext"\nlocal C = terralib.includec("stdlib.h")\n\nlocal DynamicStack = terralib.memoize(function(T)\n    local struct Stack {\n        data : &T       -- Pointer to heap-allocated elements\n        size : int      -- Current number of elements\n        capacity : int  -- Maximum capacity before reallocation\n    }\n\n    Stack.staticmethods = {}\n\n    -- Enable static method dispatch (e.g., Stack.new)\n    Stack.metamethods.__getmethod = function(self, methodname)\n        return self.methods[methodname] or Stack.staticmethods[methodname]\n    end\n\n    terra Stack:size() return self.size end\n    terra Stack:capacity() return self.capacity end\n\n    -- Macro for get/set access: stack(i)\n    Stack.metamethods.__apply = macro(function(self, i)\n        return `self.data[i]\n    end)\n\n    -- Initialize with null pointer and zero size/capacity\n    terra Stack:__init()\n        self.data = nil\n        self.size = 0\n        self.capacity = 0\n    end\n\n    -- Free heap memory and reset state\n    terra Stack:__dtor()\n        C.free(self.data)\n        self:__init()\n    end\n\n    -- Create a new stack with initial capacity\n    Stack.staticmethods.new = terra(capacity : int)\n        return Stack{data=[&T](C.malloc(capacity * sizeof(T))), capacity=capacity}\n    end\n\n    -- Reallocate when capacity is exceeded\n    terra Stack:realloc(capacity : int)\n        self.data = [&T](C.realloc(self.data, capacity * sizeof(T)))\n        self.capacity = capacity\n    end\n\n    -- Push an element, moving it into the stack\n    terra Stack:push(v : T)\n        if self.size == self.capacity then\n            self:realloc(1 + 2 * self.capacity) -- Double capacity plus one\n        end\n        self.size = self.size + 1\n        self.data[self.size - 1] = __move__(v) -- Move resource\n    end\n\n    -- Pop an element, moving it out\n    terra Stack:pop()\n        if self.size > 0 then\n            var tmp = __move__(self.data[self.size - 1]) -- Move resource\n            self.size = self.size - 1\n            return tmp\n        end\n    end\n\n    return Stack\nend)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"implementation-of-a-dynamic-vector",children:"Implementation of a dynamic vector"}),"\n",(0,r.jsx)(n.p,{children:"Next, we\u2019ll implement DynamicVector, a managed type that builds on Terra\u2019s move semantics to create a fixed-size, heap-allocated container. Unlike DynamicStack, it doesn\u2019t reallocate, maintaining a single memory chunk. It supports element access with vector(i) and introduces a user-defined cast from DynamicStack to transfer resources efficiently. With __init and __dtor defined, the auto-generated __move ensures move-only behavior by default, making it a natural extension of our exploration into Terra\u2019s ownership model."}),"\n",(0,r.jsxs)(n.p,{children:["The same general remarks apply as for the dynamic stack implementation. As for the dynamic stack, C's ",(0,r.jsx)(n.code,{children:"malloc"}),", ",(0,r.jsx)(n.code,{children:"realloc"})," and ",(0,r.jsx)(n.code,{children:"free"})," are used to allocate, reallocate, and deallocate resources, respectively."]}),"\n",(0,r.jsx)(n.p,{children:"Specific notes on memory management are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Move Semantics: The ",(0,r.jsx)(n.code,{children:"__cast"})," metamethod interpretes a reference to a stack as a reference to a vector. Paired with an auto-generated move method ",(0,r.jsx)(n.code,{children:"__move :: {&Vector, &Vector} -> {}"})," it enables moving from a stack into a vector object.\nmoves resources from a DynamicStack, nulling its capacity to enforce single ownership."]}),"\n",(0,r.jsxs)(n.li,{children:["Implementation: Implements ",(0,r.jsx)(n.code,{children:"__init"})," and ",(0,r.jsx)(n.code,{children:"__dtor"}),"; ",(0,r.jsx)(n.code,{children:"__move"})," is auto-generated, ensuring movability without copyability by default."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-terra",children:'local DynamicVector = terralib.memoize(function(T)\n\n    local struct Vector {\n        data : &T   -- Pointer to fixed heap memory\n        size : int  -- Number of elements\n    }\n\n    Vector.staticmethods = {}\n\n    -- Enable static method dispatch (e.g., Vector.new)\n    Vector.metamethods.__getmethod = function(self, methodname)\n        return self.methods[methodname] or Vector.staticmethods[methodname]\n    end\n\n    -- Initialize with null pointer and zero size\n    terra Vector:__init()\n        self.data = nil\n        self.size = 0\n    end\n\n    -- Free heap memory and reset\n    terra Vector:__dtor()\n        C.free(self.data)\n        self.size = 0\n    end\n\n    terra Vector:size() return self.size end\n\n    -- Macro for get/set access: vector(i)\n    Vector.metamethods.__apply = macro(function(self, i)\n        return `self.data[i]\n    end)\n\n    -- Allocate a fixed-size vector\n    Vector.staticmethods.new = terra(size : int)\n        return Vector{[&T](C.malloc(size * sizeof(T))), size}\n    end\n\n    -- Import DynamicStack for casting\n    local Stack = DynamicStack(T)\n\n    -- Cast preps for calls to `__move :: {&Vector, &Vector} ` mapping a reference to a stack to a reference to a vector.\n    Vector.metamethods.__cast = function(from, to, exp)\n        if from:ispointer() and from.type == Stack and to:ispointer() and to.type == Vector then\n            return quote\n                exp.capacity = 0 -- Invalidate Stack\u2019s ownership\n            in\n                [&Vector](exp) -- Transfer to &Vector, preps for `__move :: {&Vector, &Vector} -> {}`\n            end\n        else\n            error("ArgumentError: not able to cast " .. tostring(from) .. " to " .. tostring(to) .. ".")\n        end\n    end\n\n    return Vector\nend)\n'})})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var a=t(6540);const r={},s=a.createContext(r);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);