"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[1715],{533:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>i,contentTitle:()=>l,default:()=>h,frontMatter:()=>n,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"standard-library/allocators/design","title":"Allocator base class design","description":"The overall design is based on the following key ideas:","source":"@site/docs/standard-library/allocators/design.md","sourceDirName":"standard-library/allocators","slug":"/standard-library/allocators/design","permalink":"/terra-website/docs/standard-library/allocators/design","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/standard-library/allocators/design.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Allocators in Terra","permalink":"/terra-website/docs/standard-library/allocators/intro"},"next":{"title":"A smart memory block","permalink":"/terra-website/docs/standard-library/allocators/memory-block"}}');var r=t(4848),s=t(8453);const n={},l="Allocator base class design",i={},c=[];function d(e){const a={a:"a",code:"code",h1:"h1",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.header,{children:(0,r.jsx)(a.h1,{id:"allocator-base-class-design",children:"Allocator base class design"})}),"\n",(0,r.jsx)(a.p,{children:"The overall design is based on the following key ideas:"}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsxs)(a.li,{children:["A container\u2019s ",(0,r.jsx)(a.code,{children:"new"})," method (or any factory function producing a container object) accepts an allocator by reference as an opaque object conforming to the allocator interface. This approach decouples the allocator type from the container type, eliminating the need for a template parameter to support generic allocators. This addresses a notable limitation in the C++ Standard Library, where the allocator template parameter must be specified for every container method\u2014a cumbersome requirement. For further insight into this challenge, refer to the BDE allocator model. ",(0,r.jsx)(a.a,{href:"https://github.com/bloomberg/bde/wiki/BDE-Allocator-Model",children:"BDE allocator model"}),"."]}),"\n",(0,r.jsxs)(a.li,{children:["An abstraction of a memory block that has a notion of its allocator and a notion of its size. It can therefore 'free' its own resource when it runs out of scope or it can ask for additional resources when the current resource is too small. All is packed in an economical, single-function interface, ispired by 'lua_Alloc'. See also the ",(0,r.jsx)(a.a,{href:"https://nullprogram.com/blog/2023/12/17/",children:"allocator API for C"}),"."]}),"\n",(0,r.jsxs)(a.li,{children:["Every allocator has an 'owns' method, which enables composable allocators (see Andrei Alexandrescu's talk on ",(0,r.jsx)(a.a,{href:"https://www.youtube.com/watch?v=LIb3L4vKZ7U&t=21s",children:"composable allocators in C++"}),")."]}),"\n"]})]})}function h(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,a,t)=>{t.d(a,{R:()=>n,x:()=>l});var o=t(6540);const r={},s=o.createContext(r);function n(e){const a=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),o.createElement(s.Provider,{value:a},e.children)}}}]);