"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[8266],{8453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>l});var n=o(6540);const a={},s=n.createContext(a);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(s.Provider,{value:t},e.children)}},8753:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>i});const n=JSON.parse('{"id":"standard-library/allocators/memory-block","title":"A smart memory block","description":"The allocator API is built around the abstraction of a memory block. Unlike traditional designs that store only a pointer to the allocated data, this approach encapsulates additional metadata","source":"@site/docs/standard-library/allocators/memory-block.md","sourceDirName":"standard-library/allocators","slug":"/standard-library/allocators/memory-block","permalink":"/terra-website/docs/standard-library/allocators/memory-block","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/standard-library/allocators/memory-block.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Allocator base class design","permalink":"/terra-website/docs/standard-library/allocators/design"},"next":{"title":"Allocator interface","permalink":"/terra-website/docs/standard-library/allocators/interface"}}');var a=o(4848),s=o(8453);const r={},l="A smart memory block",c={},i=[{value:"Ownership",id:"ownership",level:3},{value:"Deallocation",id:"deallocation",level:3},{value:"Copy construction / assignment",id:"copy-construction--assignment",level:3},{value:"Opaque blocks versus typed blocks and",id:"opaque-blocks-versus-typed-blocks-and",level:3},{value:"Notion of size",id:"notion-of-size",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"a-smart-memory-block",children:"A smart memory block"})}),"\n",(0,a.jsxs)(t.p,{children:["The allocator API is built around the abstraction of a memory ",(0,a.jsx)(t.code,{children:"block"}),". Unlike traditional designs that store only a pointer to the allocated data, this approach encapsulates additional metadata: the size of the resource and a reference to its allocator. The structure is defined as follows:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-terra",children:"local __Allocator = interface.Interface:new{\n    __allocators_best_friend = {&block, size_t, size_t}->{}\n}\n\nlocal struct block{\n    ptr : &T                --Pointer to the actual resource\n    nbytes : size_t         --Number of bytes allocated\n    alloc : __Allocator     --Handle to opaque allocator object\n}\n\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In this design, ",(0,a.jsx)(t.code,{children:"alloc"})," is an opaque object that conforms to the ",(0,a.jsx)(t.code,{children:"__Allocator"})," interface. This interface includes a handle to the concrete allocator and a vtable with a single function pointer, ",(0,a.jsx)(t.code,{children:"__allocators_best_friend"}),", which manages allocation, reallocation, and deallocation in a unified manner. The alloc field occupies 16 bytes\u20148 bytes for the allocator handle and 8 bytes for the function pointer\u2014providing a compact yet versatile mechanism for memory management."]}),"\n",(0,a.jsxs)(t.p,{children:["This simple yet flexible design offers significant advantages. For instance, a ",(0,a.jsx)(t.code,{children:"block"})," can free it's resources when it runs out of scope or reallocate new memory when the current resource is too small. The following sections will explore the key benefits of this approach in detail."]}),"\n",(0,a.jsx)(t.h3,{id:"ownership",children:"Ownership"}),"\n",(0,a.jsxs)(t.p,{children:["The allocator API distinguishes between three states of a memory block: empty blocks, blocks that borrow a resource, and blocks that own a resource. These states are determined by the presence or absence of a pointer to the resource (",(0,a.jsx)(t.code,{children:"alloc.ptr"}),") and a handle to the allocator (",(0,a.jsx)(t.code,{children:"alloc.handle"}),"), as defined by the following methods:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-terra",children:"block.methods.isempty = terra(self : &block)\n    return self.ptr==nil and self.alloc.handle==nil\nend\n\nblock.methods.borrows_resource = terra(self : &block)\n    return self.ptr~=nil and self.alloc.handle==nil\nend\n\nblock.methods.owns_resource = terra(self : &block)\n    return self.ptr~=nil and self.alloc.handle~=nil\nend\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This design enables straightforward ownership verification by leveraging access to the concrete allocator instance. For a given allocator ",(0,a.jsx)(t.code,{children:"A"}),", the ownership check is implemented as:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-terra",children:"terra A:owns(blk : &block) : bool\n    if not blk:isempty() then\n        return [&opaque](self) == [&opaque](blk.alloc.handle)\n    end\n    return false\nend\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Here, the method compares the allocator\u2019s handle (",(0,a.jsx)(t.code,{children:"self"}),") with the block\u2019s allocator handle, cast to an opaque pointer type, ensuring a match only for non-empty blocks managed by ",(0,a.jsx)(t.code,{children:"A"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["This is powerful, because an ",(0,a.jsx)(t.code,{children:"owns"})," method like this makes it possible to construct allocators that are compositions of others (see the talk of Andrei Alexandrescu on ",(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=LIb3L4vKZ7U&t=21s",children:"composable allocators in C++"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["The ability to query ownership in this manner unlocks significant flexibility. It facilitates the construction of composite allocators\u2014allocators built from combinations of other allocators\u2014similar to the composable allocator designs discussed by Andrei Alexandrescu in his ",(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=LIb3L4vKZ7U&t=21s",children:"talk on C++ allocator design"}),"). This capability enhances modularity and reuse, allowing developers to tailor memory management strategies to complex application requirements."]}),"\n",(0,a.jsx)(t.h3,{id:"deallocation",children:"Deallocation"}),"\n",(0,a.jsxs)(t.p,{children:["By implementing ",(0,a.jsx)(t.code,{children:"__dtor"})," from the new RAII pull request, the handle to the concrete allocator instance allows the block to be freed automatically when it runs out of scope:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-terra",children:"block.methods.__dtor = terra(self : &block)\n\n    if self:isempty() then return end\n    \n    if self:borrows_resource() then\n        self:__init()\n        return\n    end\n\n    --run destructors of other smart-blocks that are referenced\n    --by block.ptr (allowing destruction of e.g. linked lists)\n    --even with cycles.\n    ...\n    ...\n    ...\n    \n    --when the resource is owned, free the resource\n    self.alloc:__allocators_best_friend(self, 0, 0)\nend\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Similarly, it can allocate (when block is empty) or reallocate itself with the same allocator when requested. I'll get back to the implementation of the method ",(0,a.jsx)(t.code,{children:"__allocators_best_friend"})," shortly."]}),"\n",(0,a.jsx)(t.h3,{id:"copy-construction--assignment",children:"Copy construction / assignment"}),"\n",(0,a.jsx)(t.p,{children:"A specialized copy assignment is implemented (from the new RAII pull request) that returns a non-owning view of the data"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-terra",children:"block.methods.__copy = terra(from : &block, to : &block)\n    to.ptr = from.ptr\n    to.nbytes = from.nbytes\n    to.alloc.handle = nil       --reset the allocator handle to nil\n    to.alloc.vtable = nil       --reset the vtable handle to nil\nend\n"})}),"\n",(0,a.jsx)(t.p,{children:"This means that a resource is only owned by a single object, resulting in safe resource management (no double free's, etc)."}),"\n",(0,a.jsx)(t.h3,{id:"opaque-blocks-versus-typed-blocks-and",children:"Opaque blocks versus typed blocks and"}),"\n",(0,a.jsxs)(t.p,{children:["The standard ",(0,a.jsx)(t.code,{children:"block"}),", used by allocators, is an opaque block (",(0,a.jsx)(t.code,{children:"T = opaque"}),"). A ",(0,a.jsx)(t.code,{children:"__cast"})," metamethod is implemented that can cast ",(0,a.jsx)(t.code,{children:"block(opaque)"})," to any ",(0,a.jsx)(t.code,{children:"block(T)"}),", thereby reinterpreting the memory. Such a typed block can be used in containers."]}),"\n",(0,a.jsx)(t.h3,{id:"notion-of-size",children:"Notion of size"}),"\n",(0,a.jsxs)(t.p,{children:["The size of the allocated resource in terms of bytes is explicitly stored in the struct definition. The current size of a typed block in terms of number of elements ",(0,a.jsx)(t.code,{children:"T"})," is then computed as"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-terra",children:"block.methods.size = terra(self : &block) : size_t\n    return self.nbytes / [block.elsize]\nend\n"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);