"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[366],{6505:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"resource-management/raii","title":"Deterministic Automated Resource Management","description":"Resource management in programming languages generally falls into one of the following categories:","source":"@site/docs/resource-management/raii.md","sourceDirName":"resource-management","slug":"/resource-management/raii","permalink":"/terra-website/docs/resource-management/raii","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/resource-management/raii.md","tags":[],"version":"current","frontMatter":{}}');var s=i(4848),t=i(8453);const o={},a="Deterministic Automated Resource Management",l={},c=[{value:"Scope-Bound Resource Management (RAII)",id:"scope-bound-resource-management-raii",level:2},{value:"Examples of Resources Managed via RAII:",id:"examples-of-resources-managed-via-raii",level:3},{value:"Experimental Implementation Overview",id:"experimental-implementation-overview",level:2},{value:"Key Features:",id:"key-features",level:3},{value:"Design Overview",id:"design-overview",level:3},{value:"Safety and Future Work",id:"safety-and-future-work",level:2},{value:"Future Work Includes:",id:"future-work-includes",level:3},{value:"Compiler supported methods for RAII",id:"compiler-supported-methods-for-raii",level:2},{value:"Object initialization",id:"object-initialization",level:3},{value:"Copy assignment",id:"copy-assignment",level:3},{value:"Copy construction",id:"copy-construction",level:3},{value:"Object destruction",id:"object-destruction",level:3},{value:"Compositional API&#39;s",id:"compositional-apis",level:2},{value:"Examples",id:"examples",level:2},{value:"Current limitations",id:"current-limitations",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"deterministic-automated-resource-management",children:"Deterministic Automated Resource Management"})}),"\n",(0,s.jsx)(n.p,{children:"Resource management in programming languages generally falls into one of the following categories:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Manual allocation and deallocation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Automatic garbage collection"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic scope-bound resource management"})," (commonly referred to as ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization",children:"RAII"}),", or ",(0,s.jsx)(n.em,{children:"Resource Acquisition Is Initialization"}),")."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Traditionally, Terra has only supported manual, C-style resource management. While functional, this approach limits the full potential of Terra\u2019s powerful metaprogramming capabilities. To address this limitation, the current implementation introduces ",(0,s.jsx)(n.strong,{children:"automated resource management"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"scope-bound-resource-management-raii",children:"Scope-Bound Resource Management (RAII)"}),"\n",(0,s.jsxs)(n.p,{children:["The new implementation provides ",(0,s.jsx)(n.strong,{children:"scope-bound resource management (RAII)"}),", a method typically associated with systems programming languages like C++ and Rust. With RAII, a resource's lifecycle is tied to the stack object that manages it. When the object goes out of scope and is not explicitly returned, the associated resource is automatically destructed."]}),"\n",(0,s.jsx)(n.h3,{id:"examples-of-resources-managed-via-raii",children:"Examples of Resources Managed via RAII:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Allocated heap memory"}),"\n",(0,s.jsx)(n.li,{children:"Threads of execution"}),"\n",(0,s.jsx)(n.li,{children:"Open sockets"}),"\n",(0,s.jsx)(n.li,{children:"Open files"}),"\n",(0,s.jsx)(n.li,{children:"Locked mutexes"}),"\n",(0,s.jsx)(n.li,{children:"Disk space"}),"\n",(0,s.jsx)(n.li,{children:"Database connections"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"experimental-implementation-overview",children:"Experimental Implementation Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The current Terra implementation supports the ",(0,s.jsx)(n.strong,{children:"Big Three"})," (as described by the ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming)",children:"Rule of Three"})," in C++):"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Object destruction"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Copy assignment"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Copy construction"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["However, ",(0,s.jsx)(n.strong,{children:"rvalue references"})," (introduced in C++11) are not supported in Terra. As a result, the current RAII implementation is comparable to that of ",(0,s.jsx)(n.strong,{children:"C++03"})," or ",(0,s.jsx)(n.strong,{children:"Rust"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"key-features",children:"Key Features:"}),"\n",(0,s.jsx)(n.p,{children:"Compiler support is provided for the following methods:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:"A.methods.__init(self : &A)\nA.methods.__dtor(self : &A)\n(A or B).methods.__copy(from : &A, to : &B)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["These methods facilitate the implementation of smart containers and pointers, such as ",(0,s.jsx)(n.code,{children:"std::string"}),", ",(0,s.jsx)(n.code,{children:"std::vector"})," and ",(0,s.jsx)(n.code,{children:"std::unique_ptr"}),", ",(0,s.jsx)(n.code,{children:"std::shared_ptr"}),", ",(0,s.jsx)(n.code,{children:"boost:offset_ptr"})," in C++."]}),"\n",(0,s.jsx)(n.h3,{id:"design-overview",children:"Design Overview"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"No Breaking Changes: This implementation does not introduce breaking changes to existing Terra code. No new keywords are required, ensuring that existing syntax remains compatible."}),"\n",(0,s.jsx)(n.li,{children:"Type Checking Integration: These methods are introduced during the type-checking phase (handled in terralib.lua). They can be implemented as either macros or Terra functions."}),"\n",(0,s.jsx)(n.li,{children:"Composability: The implementation follows simple, consistent rules that ensure smooth compatibility with existing Terra syntax for construction, casting, and function returns."}),"\n",(0,s.jsx)(n.li,{children:"Heap resources: Heap resources are allocated and deallocated using standard C functions like malloc and free, leaving memory allocation in the hands of the programmer. The idea here is that remaining functionality, such as allocators, are implemented as libraries."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"safety-and-future-work",children:"Safety and Future Work"}),"\n",(0,s.jsx)(n.p,{children:"While safety is a growing concern in programming, the current implementation has several safety challenges, similar to those in C++ or Rust's unsafe mode."}),"\n",(0,s.jsx)(n.h3,{id:"future-work-includes",children:"Future Work Includes:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Library support for composable allocators"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Tracing or debugging allocators to detect memory leaks or other faulty behavior."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compile-time borrow checking"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Similar to Rust or Mojo, ensuring safer resource usage."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Improved lifetime analysis"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Making the compiler aware of when resources (e.g., heap allocations) are introduced."}),"\n",(0,s.jsx)(n.li,{children:"Making the compiler aware of when resources are last used."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"compiler-supported-methods-for-raii",children:"Compiler supported methods for RAII"}),"\n",(0,s.jsxs)(n.p,{children:["A managed type is one that implements at least ",(0,s.jsx)(n.code,{children:"__dtor"})," and optionally ",(0,s.jsx)(n.code,{children:"__init"})," and ",(0,s.jsx)(n.code,{children:"__copy"})," or, by induction, has fields or subfields that are of a managed type. In the following we assume ",(0,s.jsx)(n.code,{children:"struct A"})," is a managed type."]}),"\n",(0,s.jsxs)(n.p,{children:["To enable RAII, import the library ",(0,s.jsx)(n.em,{children:"/lib/terralibext.t"})," using"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-terra",children:'require "terralibext"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The compiler only checks for ",(0,s.jsx)(n.code,{children:"__init"}),", ",(0,s.jsx)(n.code,{children:"__dtor"})," and ",(0,s.jsx)(n.code,{children:"__copy"})," in case this library is loaded."]}),"\n",(0,s.jsx)(n.h3,{id:"object-initialization",children:"Object initialization"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"__init"})," is used to initialize managed variables:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"A.methods.__init(self : &A)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The compiler checks for an ",(0,s.jsx)(n.code,{children:"__init"})," method in any variable definition statement, without explicit initializer, and emits the call right after the variable definition, e.g."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"var a : A\na:__init()    --generated by compiler\n"})}),"\n",(0,s.jsx)(n.h3,{id:"copy-assignment",children:"Copy assignment"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"__copy"})," enables specialized copy-assignment and, combined with ",(0,s.jsx)(n.code,{children:"__init"}),", copy construction. ",(0,s.jsx)(n.code,{children:"__copy"})," takes two arguments, which can be different, as long as one of them is a managed type, e.g."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"A.metamethods.__copy(from : &A, to : &B)\n"})}),"\n",(0,s.jsx)(n.p,{children:"and / or"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"A.metamethods.__copy(from : &B, to : &A)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"a : A"})," is a managed type, then the compiler will replace a regular assignment by a call to the implemented ",(0,s.jsx)(n.code,{children:"__copy"})," method"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"b = a   ----\x3e   A.methods.__copy(a, b) \n"})}),"\n",(0,s.jsx)(n.p,{children:"or"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"a = b   ----\x3e   A.methods.__copy(b, a)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"__copy"})," can be a (overloaded) terra function or a macro."]}),"\n",(0,s.jsxs)(n.p,{children:["The programmer is responsible for managing any heap resources associated with the arguments of the ",(0,s.jsx)(n.code,{children:"__copy"})," method."]}),"\n",(0,s.jsx)(n.h3,{id:"copy-construction",children:"Copy construction"}),"\n",(0,s.jsxs)(n.p,{children:["In object construction, ",(0,s.jsx)(n.code,{children:"__copy"})," is combined with ",(0,s.jsx)(n.code,{children:"__init"})," to perform copy construction. For example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"var b : B = a\n"})}),"\n",(0,s.jsx)(n.p,{children:"is replaced by the following statements"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"var b : B\nb:__init()              --generated by compiler if `__init` is implemented\nA.methods.__copy(a, b)  --generated by compiler\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the right ",(0,s.jsx)(n.code,{children:"__copy"})," method is not implemented but a user defined ",(0,s.jsx)(n.code,{children:"__cast"})," metamethod exists that can cast one of the arguments to the correct type, then the cast is performed and then the relevant copy method is applied."]}),"\n",(0,s.jsx)(n.h3,{id:"object-destruction",children:"Object destruction"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"__dtor"})," can be used to free heap memory"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"A.methods.__dtor(self : &A)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The implementation adds a deferred call to ",(0,s.jsx)(n.code,{children:"__dtor "})," near the end of a scope, right before a potential return statement, for all variables local to the current scope that are not returned. Hence, ",(0,s.jsx)(n.code,{children:"__dtor"})," is tied to the lifetime of the object. For example, for a block of code the compiler would generate"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"do\n    var x : A, y : A\n    ...\n    ...\n    defer x:__dtor()    --generated by compiler\n    defer y:__dtor()    --generated by compiler\nend\n"})}),"\n",(0,s.jsx)(n.p,{children:"or in case of a terra function"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"terra foo(x : A)\n    var y : A, z : A\n    ...\n    ...\n    defer z:__dtor()    --generated by compiler\n    return y\nend\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"__dtor"})," is also called before any regular assignment (if a __copy method is not implemented)  to free 'old' resources. So"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"a = b\n"})}),"\n",(0,s.jsx)(n.p,{children:"is replaced by"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"a:__dtor()  --generated by compiler\na = b\n"})}),"\n",(0,s.jsx)(n.h2,{id:"compositional-apis",children:"Compositional API's"}),"\n",(0,s.jsxs)(n.p,{children:["If a struct has fields or subfields that are managed types, but do not implement ",(0,s.jsx)(n.code,{children:"__init"}),", ",(0,s.jsx)(n.code,{children:"__copy"})," or ",(0,s.jsx)(n.code,{children:"__dtor"}),", then the compiler will generate default methods that inductively call existing ",(0,s.jsx)(n.code,{children:"__init"}),", ",(0,s.jsx)(n.code,{children:"__copy"})," or ",(0,s.jsx)(n.code,{children:"__dtor"})," methods for its fields and subfields. This enables compositional API's like ",(0,s.jsx)(n.code,{children:"vector(vector(int))"})," or  ",(0,s.jsx)(n.code,{children:"vector(string)"}),". This is implemented as an extension to ",(0,s.jsx)(n.em,{children:"terralib.lua"})," in ",(0,s.jsx)(n.em,{children:"lib/terralibext.t"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.p,{children:"The following files have been added to the terra testsuite:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"raii.t"})," tests whether ",(0,s.jsx)(n.code,{children:"__dtor"}),", ",(0,s.jsx)(n.code,{children:"__init"}),", and ",(0,s.jsx)(n.code,{children:"__copy"})," are evaluated correctly for simple datatypes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"raii-copyctr.t"})," tests ",(0,s.jsx)(n.code,{children:"__copy"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"raii-copyctr-cast.t"})," tests the combination of ",(0,s.jsx)(n.code,{children:"metamethods.__cast"})," and ",(0,s.jsx)(n.code,{children:"__copy"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"raii-unique_ptr.t"})," tests some functionality of a unique pointer type."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"raii-shared_ptr.t"})," tests some functionality of a shared pointer type."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"raii-offset_ptr.t"})," tests some functionality of an offset pointer implementation, found e.g. in ",(0,s.jsx)(n.em,{children:"boost.cpp"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"raii-compose.t"})," tests the compositional aspect."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You can have a look there for some common code patterns."}),"\n",(0,s.jsx)(n.h2,{id:"current-limitations",children:"Current limitations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The implementation is not aware of when an actual heap allocation is made and therefore assumes that a managed variable always carries a heap resource. It is up to the programmer to properly initialize pointer variables to nil to avoid calling 'free' on uninitialized pointers."}),"\n",(0,s.jsxs)(n.li,{children:["Tuple (copy) assignment (regular or using ",(0,s.jsx)(n.code,{children:"__copy"}),") are prohibited by the compiler in case of managed variables. This is done to prevent memory leaks or unwanted deletions in assignments such as","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"a, b = b, a\n"})}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var r=i(6540);const s={},t=r.createContext(s);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);