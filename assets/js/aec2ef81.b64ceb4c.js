"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[3254],{1991:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"standard-library/allocators/intro","title":"Allocators in Terra","description":"Allocators give developers the power to manage memory with precision, choosing where and how memory is allocated\u2014whether from the stack for quick, temporary objects or the heap for longer-lived data. This flexibility helps optimize performance, reduce memory fragmentation, and keep related data close together for faster access, which is crucial for high-performance applications.","source":"@site/docs/standard-library/allocators/intro.md","sourceDirName":"standard-library/allocators","slug":"/standard-library/allocators/intro","permalink":"/terra-website/docs/standard-library/allocators/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/standard-library/allocators/intro.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Terra\'s Standard Library","permalink":"/terra-website/docs/standard-library/intro"},"next":{"title":"Allocator base class design","permalink":"/terra-website/docs/standard-library/allocators/design"}}');var o=r(4848),s=r(8453);const i={},n="Allocators in Terra",l={},c=[{value:"Design Philosophy",id:"design-philosophy",level:2},{value:"What\u2019s Next",id:"whats-next",level:2}];function d(e){const t={h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"allocators-in-terra",children:"Allocators in Terra"})}),"\n",(0,o.jsx)(t.p,{children:"Allocators give developers the power to manage memory with precision, choosing where and how memory is allocated\u2014whether from the stack for quick, temporary objects or the heap for longer-lived data. This flexibility helps optimize performance, reduce memory fragmentation, and keep related data close together for faster access, which is crucial for high-performance applications."}),"\n",(0,o.jsx)(t.h2,{id:"design-philosophy",children:"Design Philosophy"}),"\n",(0,o.jsx)(t.p,{children:"Terra\u2019s allocator system is designed to be simple, extensible, and composable, integrating seamlessly with its low-level capabilities. Unlike C++, which often ties allocators to container templates, Terra treats allocators as opaque objects that implement an allocator interface. This approach decouples the allocator type from the container type, eliminating the need for a template parameter to support generic allocators. Additionally, Terra makes it easy to implement custom allocators without added complexity, enhancing usability for developers."}),"\n",(0,o.jsx)(t.h2,{id:"whats-next",children:"What\u2019s Next"}),"\n",(0,o.jsx)(t.p,{children:"This guide will walk you through the allocator system\u2019s design, covering key abstractions like memory blocks and interfaces, and conclude with practical tutorials. You\u2019ll learn how to use the default allocator and explore advanced features, such as using a memory-tracing allocator, in practical Terra projects."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>n});var a=r(6540);const o={},s=a.createContext(o);function i(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function n(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);