"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[4803],{7207:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"core-language/resource-management/tutorial/move-semantics","title":"Tutorial - Move semantics in Terra","description":"In this tutorial, we explore Terra\u2019s resource management system through the lens of move semantics\u2014its default approach to handling resources. We\u2019ll implement basic data structures to demonstrate how managed types integrate seamlessly, showcasing the power and simplicity of ownership transfer in Terra.","source":"@site/docs/core-language/resource-management/tutorial/move-semantics.md","sourceDirName":"core-language/resource-management/tutorial","slug":"/core-language/resource-management/tutorial/move-semantics","permalink":"/terra-website/docs/core-language/resource-management/tutorial/move-semantics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/core-language/resource-management/tutorial/move-semantics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Comparisons with C++ and Rust","permalink":"/terra-website/docs/core-language/resource-management/comparison"},"next":{"title":"Tutorial - Value semantics","permalink":"/terra-website/docs/core-language/resource-management/tutorial/value-semantics"}}');var i=t(4848),r=t(8453);const s={},o="Tutorial - Move semantics in Terra",c={},l=[{value:"Tutorial setup",id:"tutorial-setup",level:2},{value:"Implementation of a dynamic stack",id:"implementation-of-a-dynamic-stack",level:2},{value:"Implementation of a dynamic vector",id:"implementation-of-a-dynamic-vector",level:2},{value:"Implementation of an aggregate managed type",id:"implementation-of-an-aggregate-managed-type",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"tutorial---move-semantics-in-terra",children:"Tutorial - Move semantics in Terra"})}),"\n",(0,i.jsx)(n.p,{children:"In this tutorial, we explore Terra\u2019s resource management system through the lens of move semantics\u2014its default approach to handling resources. We\u2019ll implement basic data structures to demonstrate how managed types integrate seamlessly, showcasing the power and simplicity of ownership transfer in Terra."}),"\n",(0,i.jsx)(n.p,{children:"We\u2019ll build the following managed types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DynamicStack"}),": A dynamically sized container that allocates memory on the heap. It offers element access, push and pop methods, and automatically reallocates resources when capacity is exceeded."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DynamicVector"}),": A dynamically sized container that allocates a single chunk of heap memory without reallocation. It provides element access and supports a user-defined cast from a ",(0,i.jsx)(n.code,{children:"DynamicStack"})," for resource transfer."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Pair"}),": An aggregate type combining two Dynamic Vectors, with element access to its paired components."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Our focus is on Terra\u2019s move semantics: how resources are transferred efficiently by default, ensuring single ownership without unnecessary copying. Let\u2019s dive in and see these concepts in action!"}),"\n",(0,i.jsx)(n.h2,{id:"tutorial-setup",children:"Tutorial setup"}),"\n",(0,i.jsxs)(n.p,{children:["You can either download the tutorial files ",(0,i.jsx)(n.a,{href:"https://github.com/simkinetic/tutorial-move-semantics.git",children:"here"})," or follow along. We'll consider the following directory structure:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plaintext",children:"/tutorial-move-semantics/\n  \u251c\u2500\u2500 libtutorial.t\n  \u251c\u2500\u2500 tutorial.t\n  \u2514\u2500\u2500 utils.t\n"})}),"\n",(0,i.jsxs)(n.p,{children:["First we'll write a small library for logging and checking asserts. Put the code below in a file ",(0,i.jsx)(n.code,{children:"utils.t"}),". Note how easy it is to simply hijack C-functions you are familiar with."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-move-semantics/utils.t start=utils_start end=utils_end",children:'local C = terralib.includecstring [[\n    #include <stdio.h>\n    #include <stdlib.h>\n]]\n\nlocal ffi = require("ffi")\n\nlocal S = {}\n\nS.error = macro(function(expr, msg)\n    local tree = expr.tree\n    local filename = tree.filename\n    local linenumber = tree.linenumber\n    local offset = tree.offset\n    local loc = filename .. ":" .. linenumber .. "+" .. offset\n    return quote\n        terralib.debuginfo(filename, linenumber)\n        C.printf("%s: %s\\n", loc, msg)\n        escape\n            --traceback currently does not work on macos\n            if ffi.os == "Linux" then\n                emit quote terralib.traceback(nil) end\n            end\n        end\n        C.abort()\n    end\nend)\n\nS.assert = macro(function(condition)\n    return quote\n        if not condition then\n            S.error(condition, "assertion failed!")\n        end\n    end\nend)\n\nS.printf = C.printf\n\nreturn S\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The implementation of the dynamic stack, vector and vector pair will be added to a ",(0,i.jsx)(n.code,{children:"libtutorial.t"})," file."]}),"\n",(0,i.jsx)(n.h2,{id:"implementation-of-a-dynamic-stack",children:"Implementation of a dynamic stack"}),"\n",(0,i.jsxs)(n.p,{children:["Let\u2019s kick off with ",(0,i.jsx)(n.code,{children:"DynamicStack"}),", a managed type that exemplifies Terra\u2019s move semantics. This dynamic, heap-allocated container supports element access via ",(0,i.jsx)(n.code,{children:"stack(i)"}),", along with push and pop methods. It automatically reallocates when capacity is exceeded. By defining only ",(0,i.jsx)(n.code,{children:"__init"})," and ",(0,i.jsx)(n.code,{children:"__dtor"}),", we leverage Terra\u2019s auto-generated ",(0,i.jsx)(n.code,{children:"__move"})," for efficient resource transfers, enforcing move-only behavior without copying\u2014a perfect entry point to understanding Terra\u2019s default ownership and resource management."]}),"\n",(0,i.jsx)(n.p,{children:"Some general remarks are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Library Support: Load ",(0,i.jsx)(n.code,{children:"terralibext"})," for memory management and C\u2019s ",(0,i.jsx)(n.code,{children:"stdlib"})," via    ",(0,i.jsx)(n.code,{children:'terralib.includec("stdlib.h")'}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The Lua function ",(0,i.jsx)(n.code,{children:"terralib.memoize"})," enables caching of the definition ",(0,i.jsx)(n.code,{children:"DynamicStack(T)"})," for element type ",(0,i.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Static Methods:",(0,i.jsx)(n.code,{children:"Stack.metamethods.__getmethod"})," simplifies static method access, enabling calls like ",(0,i.jsx)(n.code,{children:"Stack.new"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Element Access: ",(0,i.jsx)(n.code,{children:"Stack.metamethods.__apply"}),", a macro, enables ",(0,i.jsx)(n.code,{children:"stack(i)"})," for both get/set access."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Memory Management Notes"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["C Integration: Uses ",(0,i.jsx)(n.code,{children:"malloc"}),", ",(0,i.jsx)(n.code,{children:"realloc"}),", and ",(0,i.jsx)(n.code,{children:"free"})," from C\u2019s ",(0,i.jsx)(n.code,{children:"stdlib"})," for heap management."]}),"\n",(0,i.jsxs)(n.li,{children:["Move Semantics: ",(0,i.jsx)(n.code,{children:"push"})," and ",(0,i.jsx)(n.code,{children:"pop"})," use ",(0,i.jsx)(n.code,{children:"__move__"})," to transfer resources via a type\u2019s ",(0,i.jsx)(n.code,{children:"__move"})," method (if defined), avoiding copies."]}),"\n",(0,i.jsxs)(n.li,{children:["Implementation: Implements ",(0,i.jsx)(n.code,{children:"__init"})," and ",(0,i.jsx)(n.code,{children:"__dtor"}),"; ",(0,i.jsx)(n.code,{children:"__move"})," is auto-generated, making the stack movable but not copyable by default."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-move-semantics/libtutorial.t start=dynamic_stack_start end=dynamic_stack_end",children:'local DynamicStack = terralib.memoize(function(T)\n    local struct Stack {\n        data : &T       -- Pointer to heap-allocated elements\n        size : int      -- Current number of elements\n        capacity : int  -- Maximum capacity before reallocation\n    }\n\n    -- This table stores all the static methods\n    Stack.staticmethods = {}\n\n    -- Enable static method dispatch (e.g., Stack.new)\n    Stack.metamethods.__getmethod = function(self, methodname)\n        return self.methods[methodname] or Stack.staticmethods[methodname]\n    end\n\n    terra Stack:size() return self.size end\n    terra Stack:capacity() return self.capacity end\n\n    -- Macro for get/set access: stack(i)\n    Stack.metamethods.__apply = macro(function(self, i)\n        return `self.data[i]\n    end)\n\n    -- Initialize with null pointer and zero size/capacity\n    terra Stack:__init()\n        self.data = nil\n        self.size = 0\n        self.capacity = 0\n    end\n\n    -- Free heap memory and reset state\n    terra Stack:__dtor()\n        if self.data~=nil then\n            utils.printf("Deleting stack.\\n")\n            C.free(self.data)\n            self.data = nil\n        end\n    end\n\n    -- Create a new stack with initial capacity\n    Stack.staticmethods.new = terra(capacity : int)\n        return Stack{data=[&T](C.malloc(capacity * sizeof(T))), capacity=capacity}\n    end\n\n    -- Reallocate when capacity is exceeded\n    terra Stack:realloc(capacity : int)\n        utils.printf("Reallocating stack memory.\\n")\n        self.data = [&T](C.realloc(self.data, capacity * sizeof(T)))\n        self.capacity = capacity\n    end\n\n    -- Push an element, moving it into the stack\n    terra Stack:push(v : T)\n        if self.size == self.capacity then\n            self:realloc(1 + 2 * self.capacity) -- Double capacity plus one\n        end\n        self.size = self.size + 1\n        self.data[self.size - 1] = __move__(v) -- Explicit move, avoiding copy when `v` is managed and copyable\n    end\n\n    -- Pop an element, moving it out\n    terra Stack:pop()\n        if self.size > 0 then\n            var tmp = __move__(self.data[self.size - 1]) -- Explicit move, cleaning resources of Stack element in case `T` is managed\n            self.size = self.size - 1\n            return tmp\n        end\n    end\n\n    return Stack\nend)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"implementation-of-a-dynamic-vector",children:"Implementation of a dynamic vector"}),"\n",(0,i.jsxs)(n.p,{children:["Next, we\u2019ll implement ",(0,i.jsx)(n.code,{children:"DynamicVector"}),", a managed type that builds on Terra\u2019s move semantics to create a fixed-size, heap-allocated container. Unlike ",(0,i.jsx)(n.code,{children:"DynamicStack"}),", it doesn\u2019t reallocate, maintaining a single memory chunk. It supports element access with ",(0,i.jsx)(n.code,{children:"vector(i)"})," and introduces a user-defined cast from ",(0,i.jsx)(n.code,{children:"DynamicStack"})," to transfer resources efficiently. With ",(0,i.jsx)(n.code,{children:"__init"})," and ",(0,i.jsx)(n.code,{children:"__dtor"})," defined, the auto-generated ",(0,i.jsx)(n.code,{children:"__move"})," ensures move-only behavior by default, making it a natural extension of our exploration into Terra\u2019s ownership model."]}),"\n",(0,i.jsxs)(n.p,{children:["The same general remarks apply as for the ",(0,i.jsx)(n.code,{children:"DynamicStack"})," implementation. C's ",(0,i.jsx)(n.code,{children:"malloc"}),", ",(0,i.jsx)(n.code,{children:"realloc"})," and ",(0,i.jsx)(n.code,{children:"free"})," are used to allocate, reallocate, and deallocate resources, respectively."]}),"\n",(0,i.jsx)(n.p,{children:"Specific notes on memory management are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Move Semantics: The ",(0,i.jsx)(n.code,{children:"__cast"})," metamethod reinterpretes a reference to a stack as a reference to a vector. Paired with an auto-generated move method ",(0,i.jsx)(n.code,{children:"__move :: {&Vector, &Vector} -> {}"})," it enables moving from a stack into a vector object."]}),"\n",(0,i.jsxs)(n.li,{children:["Implementation: Implements ",(0,i.jsx)(n.code,{children:"__init"})," and ",(0,i.jsx)(n.code,{children:"__dtor"}),"; ",(0,i.jsx)(n.code,{children:"__move"})," is auto-generated, ensuring movability without copyability by default."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-move-semantics/libtutorial.t start=dynamic_vector_start end=dynamic_vector_end",children:'local DynamicVector = terralib.memoize(function(T)\n\n    local struct Vector {\n        data : &T   -- Pointer to fixed heap memory\n        size : int  -- Number of elements\n    }\n\n    -- This table stores all the static methods\n    Vector.staticmethods = {}\n\n    -- Enable static method dispatch (e.g., Vector.new)\n    Vector.metamethods.__getmethod = function(self, methodname)\n        return self.methods[methodname] or Vector.staticmethods[methodname]\n    end\n\n    -- Initialize with null pointer and zero size\n    terra Vector:__init()\n        self.data = nil\n        self.size = 0\n    end\n\n    -- Free heap memory and reset\n    terra Vector:__dtor()\n        if self.data~=nil then\n            utils.printf("Deleting vector.\\n")\n            C.free(self.data)\n            self.data = nil\n            self.size = 0\n        end\n    end\n\n    terra Vector:size() return self.size end\n\n    -- Macro for get/set access: vector(i)\n    Vector.metamethods.__apply = macro(function(self, i)\n        return `self.data[i]\n    end)\n\n    -- Allocate a dynamic vector of `size`\n    Vector.staticmethods.new = terra(size : int)\n        return Vector{data=[&T](C.malloc(size * sizeof(T))), size=size}\n    end\n\n    -- Import DynamicStack for casting\n    local Stack = DynamicStack(T)\n\n    -- Reinterprete a reference to a stack to a reference of a vector. This is for example used in `__move :: {&Vector, &Vector}` when one of the arguments is a pointer to a stack\n    Vector.metamethods.__cast = function(from, to, exp)\n        if from:ispointer() and from.type == Stack and to:ispointer() and to.type == Vector then\n            return quote\n                exp.capacity = 0 -- Invalidate Stack\u2019s ownership\n            in\n                [&Vector](exp) -- Transfer to &Vector, preps for `__move :: {&Vector, &Vector} -> {}`\n            end\n        else\n            error("ArgumentError: not able to cast " .. tostring(from) .. " to " .. tostring(to) .. ".")\n        end\n    end\n\n    return Vector\nend)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"implementation-of-an-aggregate-managed-type",children:"Implementation of an aggregate managed type"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"DualVector"})," is an aggregate datastructure of two ",(0,i.jsx)(n.code,{children:"DynamicVector"}),"'s. Since ",(0,i.jsx)(n.code,{children:"DynamicVector"})," is a managed type, ",(0,i.jsx)(n.code,{children:"DualVector"})," is too. It's ",(0,i.jsx)(n.code,{children:"__init"}),", ",(0,i.jsx)(n.code,{children:"__move"}),", and ",(0,i.jsx)(n.code,{children:"__dtor"})," method will be auto-generated."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-move-semantics/libtutorial.t start=dynamic_vector_pair_start end=dynamic_vector_pair_end",children:'local DynamicVectorPair = terralib.memoize(function(T)\n\n    local Vector = DynamicVector(T)\n\n    local struct Pair {\n        first : Vector\n        second : Vector\n    }\n\n    -- This table stores all the static methods\n    Pair.staticmethods = {}\n\n    -- Enable static method dispatch (e.g., Pair.new)\n    Pair.metamethods.__getmethod = function(self, methodname)\n        return self.methods[methodname] or Pair.staticmethods[methodname]\n    end\n\n    -- Create a new `DynamicVectorPair`. Note that the function arguments are passed by value. Since `Vector` does not implement `__copy`, the function argumens will be moved from by default. \n    Pair.staticmethods.new = terra(first : Vector, second : Vector)\n        utils.assert(first:size() == second:size(), "Error: sizes are not compatible.")\n        return Pair{first=first, second=second}\n    end\n\n    -- Macro for get/set access: dualvector(i)\n    Pair.metamethods.__apply = macro(function(self, i)\n        return quote\n        in\n            self.first(i), self.second(i)\n        end\n    end)\n\n    terra Pair:size() return self.first:size() end\n\n    return Pair\nend)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Consider next the following application code where the data structures are combined. We'll highlight where moves or copies are taking place"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-move-semantics/tutorial.t start=tutorial_start end=tutorial_end",children:'local utils = require("utils")\nlocal lib = require("libtutorial")\n\nlocal Stack = lib.DynamicStack(int)\nlocal Vector = lib.DynamicVector(int)\nlocal VectorPair = lib.DynamicVectorPair(int)\n\nterra main()\n    utils.printf("hello there\\n")\n    -- create a stack and push some data\n    var s = Stack.new(3)\n    utils.printf("Adding three elements to \'s\'.\\n")\n    s:push(1)\n    s:push(2)\n    s:push(3)\n    utils.printf("Adding two more elements to \'s\'.\\n")\n    s:push(4) --reallocating here\n    s:push(5)\n\n    -- move contents of `s` into a Vector\n    utils.printf("Move \'s\' -> \'v\'\\n")\n    utils.assert(s:size() == 5)\n    var v : Vector = s\n    utils.assert(s:size() == 0)\n    utils.assert(v:size() == 5)\n\n    -- create another stack and push some data\n    var t = Stack.new(5)\n    t:push(1)\n    t:push(2)\n    t:push(3)\n    t:push(2)\n    t:push(1)\n\n    -- move contents of `t` into a Vector\n    utils.printf("Move \'t\' -> \'w\'\\n")\n    utils.assert(t:size() == 5)\n    var w : Vector = t\n    utils.assert(t:size() == 0)\n    utils.assert(w:size() == 5)\n\n    -- move contents of vector v, w into the aggregate data-structure\n    utils.printf("Move \'(v, w)\' -> \'dual\'\\n")\n    var dual = VectorPair.new(v, w)\n    utils.assert(dual:size() == 5)\n    utils.assert(v:size() == 0 and w:size() == 0)\n\n    -- print contents of aggregate data type\n    utils.printf("Contents of \'dual\':\\n")\n    for i=0,5 do\n        var x, y = dual(i)\n        utils.printf("  dual(%d) = (%d, %d)\\n", i, x, y)\n    end \n\nend\n\nmain()\n'})})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);