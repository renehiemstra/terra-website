"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[9017],{4853:(e,n,i)=>{i.d(n,{c:()=>s,x:()=>t});i(6540);var r=i(4848);const t=e=>{let{children:n}=e;return(0,r.jsx)("div",{style:{display:"flex",gap:"1rem",flexWrap:"wrap"},children:n})},s=e=>{let{children:n,title:i}=e;return(0,r.jsxs)("div",{style:{flex:1,minWidth:"300px"},children:[i&&(0,r.jsx)("div",{style:{color:"var(--ifm-font-color-base)",padding:"0.5rem 1rem",borderRadius:"var(--ifm-pre-border-radius, 4px) var(--ifm-pre-border-radius, 4px) 0 0",borderBottom:"none",fontSize:"0.9rem",fontWeight:"bold"},children:i}),(0,r.jsx)("div",{style:{marginTop:i?"0":"inherit",borderRadius:i?"0 0 var(--ifm-pre-border-radius, 4px) var(--ifm-pre-border-radius, 4px)":"var(--ifm-pre-border-radius, 4px)",overflow:"hidden"},children:n})]})}},5590:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>c,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"getting-started/terra-for-cpp","title":"Terra for C / C++ programmers","description":"Terra is a low-level, statically-typed language designed to interoperate seamlessly with Lua, offering semantics very similar to C/C++. However, its tight integration with Lua means that familiar C++ constructs are often expressed differently. This reference sheet bridges the gap by comparing C++ snippets with their Terra-Lua equivalents, helping C++ programmers transition to Terra. Where applicable, a third column illustrates how to meta-program these constructs using Lua\'s dynamic capabilities.","source":"@site/docs/getting-started/terra-for-cpp.mdx","sourceDirName":"getting-started","slug":"/getting-started/terra-for-cpp","permalink":"/terra-website/docs/getting-started/terra-for-cpp","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/getting-started/terra-for-cpp.mdx","tags":[],"version":"current","frontMatter":{"id":"terra-for-cpp","title":"Terra for C / C++ programmers"},"sidebar":"tutorialSidebar","previous":{"title":"Your first programm","permalink":"/terra-website/docs/getting-started/your-first-program"},"next":{"title":"intro","permalink":"/terra-website/docs/core-language/intro"}}');var t=i(4848),s=i(8453),a=i(4853);const c={id:"terra-for-cpp",title:"Terra for C / C++ programmers"},l="Terra for C / C++ programmers",o={},d=[{value:"Compilation Models: Ahead-of-Time, Dynamic, and JIT",id:"compilation-models-ahead-of-time-dynamic-and-jit",level:2},{value:"Ahead-of-Time Compilation (C++)",id:"ahead-of-time-compilation-c",level:3},{value:"Dynamic Compilation (Interpreted Languages)",id:"dynamic-compilation-interpreted-languages",level:3},{value:"Just-In-Time Compilation (Terra)",id:"just-in-time-compilation-terra",level:3},{value:"Contexts",id:"contexts",level:2},{value:"Preprocessor",id:"preprocessor",level:2},{value:"Using Multiple Files",id:"using-multiple-files",level:3},{value:"Using C Functions",id:"using-c-functions",level:3},{value:"Preprocessor Macro Equivalents:",id:"preprocessor-macro-equivalents",level:3},{value:"Macro functions:",id:"macro-functions",level:3},{value:"Conditional Compilation:",id:"conditional-compilation",level:3},{value:"Literals",id:"literals",level:2},{value:"Notes",id:"notes",level:3},{value:"Declarations and Type Constructors",id:"declarations-and-type-constructors",level:2},{value:"Declaring Variables",id:"declaring-variables",level:3},{value:"Sizing integer types:",id:"sizing-integer-types",level:3},{value:"Non-integer primitive types:",id:"non-integer-primitive-types",level:3},{value:"Multiple Declarations",id:"multiple-declarations",level:3},{value:"Arrays",id:"arrays",level:3}];function h(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"terra-for-c--c-programmers",children:"Terra for C / C++ programmers"})}),"\n",(0,t.jsx)(n.p,{children:"Terra is a low-level, statically-typed language designed to interoperate seamlessly with Lua, offering semantics very similar to C/C++. However, its tight integration with Lua means that familiar C++ constructs are often expressed differently. This reference sheet bridges the gap by comparing C++ snippets with their Terra-Lua equivalents, helping C++ programmers transition to Terra. Where applicable, a third column illustrates how to meta-program these constructs using Lua's dynamic capabilities."}),"\n",(0,t.jsx)(n.h2,{id:"compilation-models-ahead-of-time-dynamic-and-jit",children:"Compilation Models: Ahead-of-Time, Dynamic, and JIT"}),"\n",(0,t.jsxs)(n.p,{children:["Understanding how code is compiled and executed is key to grasping the differences between C++ and Terra. C++ relies on ",(0,t.jsx)(n.strong,{children:"ahead-of-time (AOT)"})," compilation, where all type checking, code generation, and optimization occur well before the program runs. In contrast, fully ",(0,t.jsx)(n.strong,{children:"dynamic"})," systems, like some interpreted languages, process code at runtime, allowing flexibility but sacrificing performance. Terra uses ",(0,t.jsx)(n.strong,{children:"just-in-time (JIT)"})," compilation, a hybrid approach that compiles code right before execution, blending the benefits of static type safety with runtime flexibility. This section explores these models, showing how they shape C++ and Terra\u2019s behavior."]}),"\n",(0,t.jsx)(n.h3,{id:"ahead-of-time-compilation-c",children:"Ahead-of-Time Compilation (C++)"}),"\n",(0,t.jsx)(n.p,{children:"In AOT compilation, the entire program is translated to machine code during a separate build phase, long before runtime. C++ exemplifies this model, using a preprocessor, compiler, and linker to produce an executable."}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int f() {\t\n    int a[3] = {0, 1, 2};\t\n    return a[0];\t\n}\t\nint main() {\t\n  return f();\n}\n"})})}),(0,t.jsxs)(a.c,{title:"C++ AOT compiler: ",children:[(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Preprocessor resolves ",(0,t.jsx)(n.code,{children:"#include"})," and macros."]}),"\n",(0,t.jsxs)(n.li,{children:["Compiler checks types (e.g., ",(0,t.jsx)(n.code,{children:"int[3]"}),") and generates object code."]}),"\n",(0,t.jsx)(n.li,{children:"Linker combines object files into an executable."}),"\n"]}),(0,t.jsx)(n.p,{children:"At runtime, the program executes directly with no further compilation."})]})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": AOT compilation ensures static type safety and optimization before execution, but it lacks runtime adaptability. All decisions (e.g., array sizes, types) are fixed at compile time."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"dynamic-compilation-interpreted-languages",children:"Dynamic Compilation (Interpreted Languages)"}),"\n",(0,t.jsx)(n.p,{children:"Dynamic systems interpret or compile code at runtime, often line-by-line, allowing types and structures to change during execution. This is common in languages like Python or Lua without JIT."}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def f():\n    a = [0, 1, 2]  # List, not a fixed array\n    a.append(3)    # Modified at runtime\n    return a[0]\n\nprint(f())\n"})})}),(0,t.jsx)(a.c,{title:"Python interpreter and dynamic compilation: ",children:(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["No ahead-of-time type checking\u2014",(0,t.jsx)(n.code,{children:"a"})," is dynamically typed."]}),"\n",(0,t.jsxs)(n.li,{children:["The list ",(0,t.jsx)(n.code,{children:"a"})," can grow or change during execution."]}),"\n",(0,t.jsx)(n.li,{children:"Performance is slower due to runtime interpretation, but flexibility is high."}),"\n"]})})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": Dynamic compilation allows runtime modifications (e.g., resizing arrays), but it sacrifices the performance and type safety of compiled languages like C++."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"just-in-time-compilation-terra",children:"Just-In-Time Compilation (Terra)"}),"\n",(0,t.jsxs)(n.p,{children:["Terra\u2019s JIT compilation occurs right before runtime, when a ",(0,t.jsx)(n.code,{children:"terra"})," function is first invoked or explicitly compiled. Lua drives this process, defining types and generating code that is then fixed for execution, offering a balance between AOT\u2019s performance and dynamic compilation."]}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"Terra",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:'terra f()\n    var a : int[3] = array(0, 1, 2)\n    return a[0]\nend\n\n\nf()  -- Triggers JIT compilation\n\n-- AOT example:\nterralib.saveobj("f.so", { f = f })  -- Generates shared library\n'})})}),(0,t.jsxs)(a.c,{title:"Terra\u2019s JIT process: ",children:[(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Lua runs and defines ",(0,t.jsx)(n.code,{children:"f"})," at compiletime."]}),"\n",(0,t.jsxs)(n.li,{children:["On first call to ",(0,t.jsx)(n.code,{children:"f()"}),", Terra\u2019s JIT compiler checks types (e.g., ",(0,t.jsx)(n.code,{children:"int[3]"}),"), evaluates ",(0,t.jsx)(n.code,{children:"array(0, 1, 2)"}),", and generates machine code."]}),"\n",(0,t.jsxs)(n.li,{children:["The compiled ",(0,t.jsx)(n.code,{children:"f"})," executes with fixed types and sizes, reused on subsequent calls unless redefined."]}),"\n"]}),(0,t.jsxs)(n.p,{children:["For AOT, ",(0,t.jsx)(n.code,{children:"terralib.saveobj"})," compiles ",(0,t.jsx)(n.code,{children:"f"})," into a shared library (e.g., ",(0,t.jsx)(n.code,{children:"f.so"}),"), which can be linked into other programs, bypassing JIT at runtime."]})]})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": Terra\u2019s JIT compilation happens just before runtime, locking in static definitions (e.g., ",(0,t.jsx)(n.code,{children:"int[3]"}),") once compiled. This contrasts with C++\u2019s AOT (done well before runtime) and dynamic systems (during runtime). Lua\u2019s role enables code generation (e.g., via ",(0,t.jsx)(n.code,{children:"quote"}),") during compile time, but the resulting Terra code is static in the runtime context."]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),': The "just in time" nature defers compilation until needed, improving startup speed for development while delivering near-AOT performance. Unlike dynamic systems, Terra\u2019s arrays and types cannot change mid-execution in the runtime context.']}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": Terra\u2019s unique AOT support allows generating shared libraries (e.g., via ",(0,t.jsx)(n.code,{children:"terralib.saveobj"}),"), which can be linked against like C++ libraries. This offloads compilation from JIT to ahead-of-time, keeping JIT fast for development while enabling optimized, reusable binaries for deployment."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"contexts",children:"Contexts"}),"\n",(0,t.jsx)(n.p,{children:"In multistage programming, we distinguish between compile-time and runtime contexts. In C++, compile-time includes the preprocessor and template metaprogramming, while runtime encompasses regular function and variable definitions. Similarly, in Terra, the Lua context handles compile-time metaprogramming, and Terra functions define runtime behavior. Terra's semantics are very close to C/C++, but its integration with Lua introduces unique metaprogramming techniques through quotes (`) and escapes ([ ]), enabling dynamic code generation. This section compares equivalent representations in C++ and Terra, highlighting how contexts shift between compile-time and runtime."}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"Terra",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:"-- Lua context (any Lua code here)\nMyInt = int -- assignment to Lua variable 'MyInt'\nx = global(MyInt)\n\nterra f()\n    -- Terra context\n    var bar : MyInt = x + 1\n    --        ~~~~~ _Lua_ context, any Lua can go here, but it needs to evaluate to a Terra type\n    return bar\nend\n\nstruct S {\n    a : int\n    --  ~~~ _Lua_ context, evaluates to a Terra type\n    b : float\n}\n\n-- Meta-programming Lua-Terra creates additional places where the context changes.\n\nfunction g() return `4+5 end\n--                  ~~~~ Terra context, a quote creates a Terra expression from Lua\n\nterra h()\n    var baz = [ g() ]\n    --        ~~~~~~~ Lua context, an escape breaks into Lua and evaluates to a Terra expression\nend\n"})})}),(0,t.jsx)(a.c,{title:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// function/global declaration context:\ntypedef int MyInt;\nMyInt x;\n\nint f() {\n    // C++ code context:\n    MyInt bar = x + 1;\n//  ~~~~~ C++ type context\n\n    return bar;\n}\n\nstruct S {\n    // struct definition context:\n    int a;\n // ~~~ type context\n    float b;\n};\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"preprocessor",children:"Preprocessor"}),"\n",(0,t.jsx)(n.p,{children:"C++ uses a static preprocessor to manage file inclusion, macros, and conditional compilation, relying on a multi-step build process with separate compilation for custom C code and linking for standard libraries. Terra achieves similar functionality\u2014such as integrating external code and defining reusable constructs\u2014but replaces this static approach with a dynamic, Lua-driven model. By processing code, including C headers, at runtime within Terra\u2019s just-in-time (JIT) compilation pipeline, Lua offers a flexible alternative to C++\u2019s traditional preprocessing."}),"\n",(0,t.jsx)(n.h3,{id:"using-multiple-files",children:"Using Multiple Files"}),"\n",(0,t.jsxs)(n.p,{children:["In C++, ",(0,t.jsx)(n.code,{children:"#include"})," directives bring in external code. Terra uses Lua's require function to load modules, which can contain Terra functions and definitions stored in tables."]}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"Terra",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:'local myfile = require("myfile")\n-- use Lua\'s require to load another Lua \n-- file Terra functions can be stored in \n-- a table myfiles\nterra f()\n    myfile.myfunction()\nend\n'})})}),(0,t.jsx)(a.c,{title:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include "myfile.h"\n\n\n\nvoid f() {\n    myfunction();\n}\n'})})})]}),"\n",(0,t.jsx)(n.h3,{id:"using-c-functions",children:"Using C Functions"}),"\n",(0,t.jsxs)(n.p,{children:["C++ uses ",(0,t.jsx)(n.code,{children:"#include"})," to access C standard library functions. Terra provides ",(0,t.jsx)(n.code,{children:"terralib.includec"})," and ",(0,t.jsx)(n.code,{children:"terralib.includecstring"})," to import C headers, creating a Lua table of functions and types."]}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"Terra",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:'local C = terralib.includecstring [[\n    #include<stdio.h>\n    #include<malloc.h\n]]\n-- can also use terralib.includec("stdio.h") for single file\n-- C is a table of functions (C.printf) and types (C.FILE)\nterra hello()\n    C.printf("hello, world\\n")\nend\n'})})}),(0,t.jsx)(a.c,{title:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <stdio.h>\n#include <malloc.h>\nint main() {\n    printf("hello, world\\n");\n}\n'})})})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": Terra's ",(0,t.jsx)(n.code,{children:"includecstring"})," processes C headers at Lua runtime, generating bindings automatically. Unlike C++, no separate compilation step is needed\u2014Terra compiles these into the final executable alongside Terra code."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"preprocessor-macro-equivalents",children:"Preprocessor Macro Equivalents:"}),"\n",(0,t.jsxs)(n.p,{children:["Lua variables can hold values that get substituted into Terra functions. The quotation (`) operator creates a Terra expression directly from Lua. This value can be spliced into subsequent terra code using an escape: ",(0,t.jsx)(n.code,{children:"[ ... ]"}),"."]}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"Terra",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:"local X = `3+3\n"})})}),(0,t.jsx)(a.c,{title:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"#define X (3+3)\n"})})})]}),"\n",(0,t.jsx)(n.h3,{id:"macro-functions",children:"Macro functions:"}),"\n",(0,t.jsx)(n.p,{children:"In Terra, a macro is a Lua function that returns a Terra expression that is directly spliced into surrounding Terra code. It's closely related to a macro function in C / C++."}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"Terra",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:"local F = macro(function(a,b)\n    return `a + b\nend)\n"})})}),(0,t.jsx)(a.c,{title:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"#define F(a,b) a + b\n"})})})]}),"\n",(0,t.jsx)(n.h3,{id:"conditional-compilation",children:"Conditional Compilation:"}),"\n",(0,t.jsxs)(n.p,{children:["In C++, conditional compilation relies on the preprocessor\u2019s ",(0,t.jsx)(n.code,{children:"#ifdef"})," directives, which can feel rigid and obfuscated due to their static, text-based nature. Terra achieves the same functionality\u2014selectively defining code based on conditions\u2014using Lua\u2019s clear, dynamic syntax. By leveraging Lua\u2019s runtime logic, Terra offers a more readable and flexible alternative to C++\u2019s preprocessor calls."]}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"Terra",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:'-- use Lua to control how a Terra function is defined\nif terralib.os == "Windows" then\n    terra getOS() return "Windows" end\nelse\n    terra getOS() return "Linux" end\nend\n'})})}),(0,t.jsx)(a.c,{title:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'// Use #ifdef to control how functions are defined\n#ifdef __WIN32\n    char * getOS() { return "Windows"; }\n#else\n    char * getOS() { return "Linux"; }\n#endif\n'})})})]}),"\n",(0,t.jsx)(n.h2,{id:"literals",children:"Literals"}),"\n",(0,t.jsx)(n.p,{children:"C++ and Terra both support a variety of literal types (integers, floats, strings, booleans), but Terra\u2019s integration with Lua introduces differences in syntax and behavior. While C++ uses a static, compile-time approach to literals, Terra leverages Lua\u2019s dynamic runtime environment, often requiring escapes or Lua-specific constructs to achieve equivalent results. This table compares common literals in C++ with their Terra-Lua equivalents."}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"C++"})}),(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Lua-Terra"})}),(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Description"})})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"255, 0377, 0xff"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"255, 0377, 0xff"})}),(0,t.jsx)(n.td,{children:"Integer literals in decimal (255), octal (0377), and hexadecimal (0xff) are identical in both languages, as Terra inherits C-like syntax for these."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2147483647LL, 0x7ffffffful"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2147483647LL, 0x7fffffffULL"})}),(0,t.jsxs)(n.td,{children:["Long integer literals in C++ use ",(0,t.jsx)(n.code,{children:"LL"})," or ",(0,t.jsx)(n.code,{children:"ul"})," suffixes. Terra matches LuaJIT\u2019s conventions, using ",(0,t.jsx)(n.code,{children:"LL"})," for signed long long and ",(0,t.jsx)(n.code,{children:"ULL"})," for unsigned long long, ensuring compatibility with Lua\u2019s number handling."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"123.0, 1.23e2"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"123.0, 1.23e2"})}),(0,t.jsx)(n.td,{children:"Floating-point literals (decimal and scientific notation) are the same in both languages, reflecting C\u2019s influence on Terra\u2019s syntax."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"strings\\n"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"\"strings\\n\" or 'strings\\n' or [[strings\\n]]"})}),(0,t.jsxs)(n.td,{children:["C++ uses double quotes for strings with escape sequences (e.g., ",(0,t.jsx)(n.code,{children:"\\n"}),"). Terra supports Lua\u2019s string styles: double quotes (",(0,t.jsx)(n.code,{children:'"..."'}),"), single quotes (",(0,t.jsx)(n.code,{children:"'...'"}),")\u2014which are equivalent\u2014or long brackets (",(0,t.jsx)(n.code,{children:"[[...]]"}),") for raw strings, avoiding escape sequence issues."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"'a'"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'("a")[0]'})}),(0,t.jsxs)(n.td,{children:["C++ has single-character literals with single quotes. Terra lacks a direct char literal; instead, you index a string (e.g., ",(0,t.jsx)(n.code,{children:'"a"'}),") at position 0 to get a byte value, or you could define a function for this purpose."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"hello" "world"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'[ "hello".."world" ]'})}),(0,t.jsxs)(n.td,{children:["C++ concatenates adjacent string literals at compile time. Terra uses Lua\u2019s ",(0,t.jsx)(n.code,{children:".."})," operator for string concatenation, wrapped in an escape (",(0,t.jsx)(n.code,{children:"[ ]"}),") to evaluate the Lua expression as a Terra-compatible string at runtime."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"true, false"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"true, false"})}),(0,t.jsxs)(n.td,{children:["Boolean literals are identical in both languages, as Terra adopts C++\u2019s ",(0,t.jsx)(n.code,{children:"true"})," and ",(0,t.jsx)(n.code,{children:"false"})," directly."]})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"notes",children:"Notes"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": C++ literals are resolved statically at compile time, with types inferred by the compiler (e.g., ",(0,t.jsx)(n.code,{children:"'a'"})," as ",(0,t.jsx)(n.code,{children:"char"}),", ",(0,t.jsx)(n.code,{children:'"hello"'})," as ",(0,t.jsx)(n.code,{children:"const char*"}),"). Terra\u2019s literals are processed at Lua runtime, often requiring Lua constructs (e.g., string indexing, escapes) to match C++ functionality."]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": For character literals, Terra\u2019s workaround (",(0,t.jsx)(n.code,{children:'("a")[0]'}),") returns a numeric byte value (e.g., 97 for ",(0,t.jsx)(n.code,{children:"'a'"}),"), not a distinct ",(0,t.jsx)(n.code,{children:"char"})," type. You could define a Terra function like ",(0,t.jsx)(n.code,{children:"terra char(s : rawstring) : int8 return s[0] end"})," to mimic C++\u2019s ",(0,t.jsx)(n.code,{children:"'a'"})," by converting a string to its first byte."]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": Long brackets ",(0,t.jsx)(n.code,{children:"[[...]]"})," could be confused with Terra escapes ",(0,t.jsx)(n.code,{children:"[ ... ]"})," that operate on Terra quoted expressions. In case of ambiguity, use ",(0,t.jsx)(n.code,{children:"escape ... end"})," to apply an escape instead."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"declarations-and-type-constructors",children:"Declarations and Type Constructors"}),"\n",(0,t.jsxs)(n.p,{children:["C++ and Terra both allow variable declarations within functions, but their syntax and type systems differ due to Terra\u2019s integration with Lua. C++ uses static typing with optional type inference (via ",(0,t.jsx)(n.code,{children:"auto"}),"), while Terra combines explicit typing, type inference, and Lua-driven metaprogramming for dynamic code generation. This section compares basic variable declarations in C++ with their Terra equivalents, including Terra\u2019s advanced constructs like ",(0,t.jsx)(n.code,{children:"symbol"})," and ",(0,t.jsx)(n.code,{children:"quote"})," for metaprogramming."]}),"\n",(0,t.jsx)(n.h3,{id:"declaring-variables",children:"Declaring Variables"}),"\n",(0,t.jsxs)(n.p,{children:["C++ declares variables with explicit types or inferred types using ",(0,t.jsx)(n.code,{children:"auto"}),", all resolved statically. Terra offers similar functionality with ",(0,t.jsx)(n.code,{children:"var"}),", supporting both explicit typing and inference, and extends this with Lua metaprogramming for runtime code generation."]}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void f() {\n    int x;\n    int y = 255;\n    auto z = 255;\n}\n"})})}),(0,t.jsx)(a.c,{title:"Terra",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:"terra f()\n    var x\n    var y : int = 255\n    var z = 255\nend\n"})})}),(0,t.jsx)(a.c,{title:"Metaprogrammed",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:"x = symbol(int)\ny = symbol(int)\nz = symbol(int)\nlocal zdeclare = quote \n    var [z] = 255\nend\nterra f() \n    var [x]\n    var [y]\n    [zdeclare]\n    return x + y + z\nend\n"})})})]}),"\n",(0,t.jsx)(n.h3,{id:"sizing-integer-types",children:"Sizing integer types:"}),"\n",(0,t.jsxs)(n.p,{children:["C++ provides keywords like ",(0,t.jsx)(n.code,{children:"short"})," and ",(0,t.jsx)(n.code,{children:"long"})," for sized integers, with sizes varying by platform. Terra uses explicit, portable type names (e.g., ",(0,t.jsx)(n.code,{children:"int16"}),", ",(0,t.jsx)(n.code,{children:"int64"}),") for clarity and consistency."]}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"short s; long l;\n"})})}),(0,t.jsx)(a.c,{title:"Terra",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:"var s : int16, l : int64\n"})})})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": C++\u2019s ",(0,t.jsx)(n.code,{children:"short"})," and ",(0,t.jsx)(n.code,{children:"long"})," sizes depend on the compiler and architecture, whereas Terra\u2019s ",(0,t.jsx)(n.code,{children:"int16"})," and ",(0,t.jsx)(n.code,{children:"int64"})," guarantee fixed sizes, aligning with modern C++\u2019s ",(0,t.jsx)(n.code,{children:"<cstdint>"})," (e.g., ",(0,t.jsx)(n.code,{children:"int16_t"}),", ",(0,t.jsx)(n.code,{children:"int64_t"}),")."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"non-integer-primitive-types",children:"Non-integer primitive types:"}),"\n",(0,t.jsxs)(n.p,{children:["C++ supports a range of non-integer primitives like ",(0,t.jsx)(n.code,{children:"char"}),", ",(0,t.jsx)(n.code,{children:"float"}),", and ",(0,t.jsx)(n.code,{children:"bool"}),". Terra mirrors these but adapts ",(0,t.jsx)(n.code,{children:"char"})," handling due to Lua\u2019s string-based approach."]}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"char c = 'a'; \nfloat f; double d; \nbool b;\n"})})}),(0,t.jsx)(a.c,{title:"Terra",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:"var c : int8 = ('a')[0]\nvar f :float, d : double \nvar b : bool\n"})})})]}),"\n",(0,t.jsx)(n.h3,{id:"multiple-declarations",children:"Multiple Declarations"}),"\n",(0,t.jsx)(n.p,{children:"C++ allows comma-separated declarations with a shared type, initialized in one line. Terra supports multiple declarations but requires separate type definition for each variable when initialized together."}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int a = 1,b = 2,c = 3;\n"})})}),(0,t.jsx)(a.c,{title:"Terra",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:"var a : int, b : int, c : int = 1,2,3\n"})})})]}),"\n",(0,t.jsx)(n.h3,{id:"arrays",children:"Arrays"}),"\n",(0,t.jsxs)(n.p,{children:["C++ initializes arrays with a size or an initializer list, with types and sizes resolved statically at compile time. Terra treats ",(0,t.jsx)(n.code,{children:"array"})," as an expression to populate arrays, requiring explicit type and size definitions that are fixed during just-in-time (JIT) compilation, which occurs right before runtime. The ",(0,t.jsx)(n.code,{children:"arrayof"})," function allows type specification when initializer expressions don\u2019t match the desired type, with all decisions finalized prior to execution."]}),"\n",(0,t.jsxs)(a.x,{children:[(0,t.jsx)(a.c,{title:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int a[10];\nint a[]={0,1,2};\nfloat a[]={0,1,2};\nint a[2][3]={ {1,2,3},{4,5,6} }; \n"})})}),(0,t.jsx)(a.c,{title:"Terra",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terra",children:"var a : int[10];\nvar a : int[3] = array(0,1,2)\nvar a = arrayof([float],0,1,2) \nvar a : (int[3])[2] = array(\n    array(1,2,3),\n    array(4,5,6)\n)\n"})})})]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var r=i(6540);const t={},s=r.createContext(t);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);