"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[1715],{533:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>i});const n=JSON.parse('{"id":"standard-library/allocators/design","title":"Design of allocators in terra","description":"The overall design is based on the following key ideas:","source":"@site/docs/standard-library/allocators/design.md","sourceDirName":"standard-library/allocators","slug":"/standard-library/allocators/design","permalink":"/terra-website/docs/standard-library/allocators/design","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/standard-library/allocators/design.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Allocators in Terra","permalink":"/terra-website/docs/standard-library/allocators/intro"},"next":{"title":"Concepts","permalink":"/terra-website/docs/standard-library/concepts/intro"}}');var a=t(4848),r=t(8453);const s={},l="Design of allocators in terra",c={},i=[{value:"Abstraction of a memory block",id:"abstraction-of-a-memory-block",level:2},{value:"Ownership",id:"ownership",level:3},{value:"Deallocation",id:"deallocation",level:3},{value:"Copy construction / assignment",id:"copy-construction--assignment",level:3},{value:"Opaque blocks versus typed blocks and",id:"opaque-blocks-versus-typed-blocks-and",level:3},{value:"Notion of size",id:"notion-of-size",level:3}];function d(e){const o={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(o.header,{children:(0,a.jsx)(o.h1,{id:"design-of-allocators-in-terra",children:"Design of allocators in terra"})}),"\n",(0,a.jsx)(o.p,{children:"The overall design is based on the following key ideas:"}),"\n",(0,a.jsxs)(o.ul,{children:["\n",(0,a.jsxs)(o.li,{children:["A container\u2019s ",(0,a.jsx)(o.code,{children:"new"})," method (or any factory function producing a container object) accepts an allocator by reference as an opaque object conforming to the allocator interface. This approach decouples the allocator type from the container type, eliminating the need for a template parameter to support generic allocators. This addresses a notable limitation in the C++ Standard Library, where the allocator template parameter must be specified for every container method\u2014a cumbersome requirement. For further insight into this challenge, refer to the BDE allocator model. ",(0,a.jsx)(o.a,{href:"https://github.com/bloomberg/bde/wiki/BDE-Allocator-Model",children:"BDE allocator model"}),"."]}),"\n",(0,a.jsxs)(o.li,{children:["An abstraction of a memory block that has a notion of its allocator and a notion of its size. It can therefore 'free' its own resource when it runs out of scope or it can ask for additional resources when the current resource is too small. All is packed in an economical, single-function interface, ispired by 'lua_Alloc'. See also the ",(0,a.jsx)(o.a,{href:"https://nullprogram.com/blog/2023/12/17/",children:"allocator API for C"}),"."]}),"\n",(0,a.jsxs)(o.li,{children:["Every allocator has an 'owns' method, which enables composable allocators (see Andrei Alexandrescu's talk on ",(0,a.jsx)(o.a,{href:"https://www.youtube.com/watch?v=LIb3L4vKZ7U&t=21s",children:"composable allocators in C++"}),")."]}),"\n"]}),"\n",(0,a.jsx)(o.h2,{id:"abstraction-of-a-memory-block",children:"Abstraction of a memory block"}),"\n",(0,a.jsxs)(o.p,{children:["The allocator API is built around the abstraction of a memory ",(0,a.jsx)(o.code,{children:"block"}),". Unlike traditional designs that store only a pointer to the allocated data, this approach encapsulates additional metadata: the size of the resource and a reference to its allocator. The structure is defined as follows:"]}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-terra",children:"local __Allocator = interface.Interface:new{\n    __allocators_best_friend = {&block, size_t, size_t}->{}\n}\n\nlocal struct block{\n    ptr : &T                --Pointer to the actual resource\n    nbytes : size_t         --Number of bytes allocated\n    alloc : __Allocator     --Handle to opaque allocator object\n}\n\n"})}),"\n",(0,a.jsxs)(o.p,{children:["In this design, ",(0,a.jsx)(o.code,{children:"alloc"})," is an opaque object that conforms to the ",(0,a.jsx)(o.code,{children:"__Allocator"})," interface. This interface includes a handle to the concrete allocator and a vtable with a single function pointer, ",(0,a.jsx)(o.code,{children:"__allocators_best_friend"}),", which manages allocation, reallocation, and deallocation in a unified manner. The alloc field occupies 16 bytes\u20148 bytes for the allocator handle and 8 bytes for the function pointer\u2014providing a compact yet versatile mechanism for memory management."]}),"\n",(0,a.jsxs)(o.p,{children:["This simple yet flexible design offers significant advantages. For instance, a ",(0,a.jsx)(o.code,{children:"block"})," can free it's resources when it runs out of scope or reallocate new memory when the current resource is too small. The following sections will explore the key benefits of this approach in detail."]}),"\n",(0,a.jsx)(o.h3,{id:"ownership",children:"Ownership"}),"\n",(0,a.jsxs)(o.p,{children:["The allocator API distinguishes between three states of a memory block: empty blocks, blocks that borrow a resource, and blocks that own a resource. These states are determined by the presence or absence of a pointer to the resource (",(0,a.jsx)(o.code,{children:"alloc.ptr"}),") and a handle to the allocator (",(0,a.jsx)(o.code,{children:"alloc.handle"}),"), as defined by the following methods:"]}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-terra",children:"block.methods.isempty = terra(self : &block)\n    return self.ptr==nil and self.alloc.handle==nil\nend\n\nblock.methods.borrows_resource = terra(self : &block)\n    return self.ptr~=nil and self.alloc.handle==nil\nend\n\nblock.methods.owns_resource = terra(self : &block)\n    return self.ptr~=nil and self.alloc.handle~=nil\nend\n"})}),"\n",(0,a.jsxs)(o.p,{children:["This design enables straightforward ownership verification by leveraging access to the concrete allocator instance. For a given allocator ",(0,a.jsx)(o.code,{children:"A"}),", the ownership check is implemented as:"]}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-terra",children:"terra A:owns(blk : &block) : bool\n    if not blk:isempty() then\n        return [&opaque](self) == [&opaque](blk.alloc.handle)\n    end\n    return false\nend\n"})}),"\n",(0,a.jsxs)(o.p,{children:["Here, the method compares the allocator\u2019s handle (",(0,a.jsx)(o.code,{children:"self"}),") with the block\u2019s allocator handle, cast to an opaque pointer type, ensuring a match only for non-empty blocks managed by ",(0,a.jsx)(o.code,{children:"A"}),"."]}),"\n",(0,a.jsxs)(o.p,{children:["This is powerful, because an ",(0,a.jsx)(o.code,{children:"owns"})," method like this makes it possible to construct allocators that are compositions of others (see the talk of Andrei Alexandrescu on ",(0,a.jsx)(o.a,{href:"https://www.youtube.com/watch?v=LIb3L4vKZ7U&t=21s",children:"composable allocators in C++"}),")."]}),"\n",(0,a.jsxs)(o.p,{children:["The ability to query ownership in this manner unlocks significant flexibility. It facilitates the construction of composite allocators\u2014allocators built from combinations of other allocators\u2014similar to the composable allocator designs discussed by Andrei Alexandrescu in his ",(0,a.jsx)(o.a,{href:"https://www.youtube.com/watch?v=LIb3L4vKZ7U&t=21s",children:"talk on C++ allocator design"}),"). This capability enhances modularity and reuse, allowing developers to tailor memory management strategies to complex application requirements."]}),"\n",(0,a.jsx)(o.h3,{id:"deallocation",children:"Deallocation"}),"\n",(0,a.jsxs)(o.p,{children:["By implementing ",(0,a.jsx)(o.code,{children:"__dtor"})," from the new RAII pull request, the handle to the concrete allocator instance allows the block to be freed automatically when it runs out of scope:"]}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-terra",children:"block.methods.__dtor = terra(self : &block)\n\n    if self:isempty() then return end\n    \n    if self:borrows_resource() then\n        self:__init()\n        return\n    end\n\n    --run destructors of other smart-blocks that are referenced\n    --by block.ptr (allowing destruction of e.g. linked lists)\n    --even with cycles.\n    ...\n    ...\n    ...\n    \n    --when the resource is owned, free the resource\n    self.alloc:__allocators_best_friend(self, 0, 0)\nend\n"})}),"\n",(0,a.jsxs)(o.p,{children:["Similarly, it can allocate (when block is empty) or reallocate itself with the same allocator when requested. I'll get back to the implementation of the method ",(0,a.jsx)(o.code,{children:"__allocators_best_friend"})," shortly."]}),"\n",(0,a.jsx)(o.h3,{id:"copy-construction--assignment",children:"Copy construction / assignment"}),"\n",(0,a.jsx)(o.p,{children:"A specialized copy assignment is implemented (from the new RAII pull request) that returns a non-owning view of the data"}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-terra",children:"block.methods.__copy = terra(from : &block, to : &block)\n    to.ptr = from.ptr\n    to.nbytes = from.nbytes\n    to.alloc.handle = nil       --reset the allocator handle to nil\n    to.alloc.vtable = nil       --reset the vtable handle to nil\nend\n"})}),"\n",(0,a.jsx)(o.p,{children:"This means that a resource is only owned by a single object, resulting in safe resource management (no double free's, etc)."}),"\n",(0,a.jsx)(o.h3,{id:"opaque-blocks-versus-typed-blocks-and",children:"Opaque blocks versus typed blocks and"}),"\n",(0,a.jsxs)(o.p,{children:["The standard ",(0,a.jsx)(o.code,{children:"block"}),", used by allocators, is an opaque block (",(0,a.jsx)(o.code,{children:"T = opaque"}),"). A ",(0,a.jsx)(o.code,{children:"__cast"})," metamethod is implemented that can cast ",(0,a.jsx)(o.code,{children:"block(opaque)"})," to any ",(0,a.jsx)(o.code,{children:"block(T)"}),", thereby reinterpreting the memory. Such a typed block can be used in containers."]}),"\n",(0,a.jsx)(o.h3,{id:"notion-of-size",children:"Notion of size"}),"\n",(0,a.jsxs)(o.p,{children:["The size of the allocated resource in terms of bytes is explicitly stored in the struct definition. The current size of a typed block in terms of number of elements ",(0,a.jsx)(o.code,{children:"T"})," is then computed as"]}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-terra",children:"block.methods.size = terra(self : &block) : size_t\n    return self.nbytes / [block.elsize]\nend\n"})})]})}function h(e={}){const{wrapper:o}={...(0,r.R)(),...e.components};return o?(0,a.jsx)(o,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,o,t)=>{t.d(o,{R:()=>s,x:()=>l});var n=t(6540);const a={},r=n.createContext(a);function s(e){const o=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function l(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(r.Provider,{value:o},e.children)}}}]);