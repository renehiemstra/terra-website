"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[3434],{2956:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"core-language/resource-management/tutorial/move-vs-value","title":"Tutorial - Value versus Move Semantics","description":"In this tutorial, we explore Terra\u2019s resource management system through the lens of value and move semantics. The default approach to resource management is to move resources when they are passed by value to a function or used in an assignment. Value semantics - where resources behave more like regular values - is simply achieved by implementing a copy method where you, as the programmer, are in control of how values are copied.","source":"@site/docs/core-language/resource-management/tutorial/move-vs-value.mdx","sourceDirName":"core-language/resource-management/tutorial","slug":"/core-language/resource-management/tutorial/move-vs-value","permalink":"/terra-website/docs/core-language/resource-management/tutorial/move-vs-value","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/core-language/resource-management/tutorial/move-vs-value.mdx","tags":[],"version":"current","frontMatter":{"id":"move-vs-value","title":"Tutorial - Value versus Move Semantics"},"sidebar":"tutorialSidebar","previous":{"title":"Comparisons with C++ and Rust","permalink":"/terra-website/docs/core-language/resource-management/comparison"},"next":{"title":"Terra\'s Standard Library","permalink":"/terra-website/docs/standard-library/intro"}}');var o=t(4848),i=t(8453),r=t(4853);const s={id:"move-vs-value",title:"Tutorial - Value versus Move Semantics"},c="Tutorial - Value versus Move Semantics",l={},d=[{value:"Tutorial setup",id:"tutorial-setup",level:2},{value:"Implementation of a dynamic stack",id:"implementation-of-a-dynamic-stack",level:2},{value:"Implementation of a dynamic vector",id:"implementation-of-a-dynamic-vector",level:2},{value:"Implementation of VectorPair",id:"implementation-of-vectorpair",level:2},{value:"Example use-case",id:"example-use-case",level:2}];function m(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"tutorial---value-versus-move-semantics",children:"Tutorial - Value versus Move Semantics"})}),"\n",(0,o.jsxs)(n.p,{children:["In this tutorial, we explore Terra\u2019s resource management system through the lens of value and move semantics. The default approach to resource management is to move resources when they are passed by value to a function or used in an assignment. Value semantics - where resources behave more like regular values - is simply achieved by implementing a ",(0,o.jsx)(n.code,{children:"__copy"})," method where you, as the programmer, are in control of how values are copied."]}),"\n",(0,o.jsx)(n.p,{children:"We\u2019ll implement basic data structures to demonstrate how managed types integrate seamlessly, showcasing the power and simplicity of ownership transfer in Terra."}),"\n",(0,o.jsx)(n.p,{children:"We\u2019ll build the following managed types:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"DynamicStack"}),": A dynamically sized container that allocates memory on the heap. It offers element access, push and pop methods, and automatically reallocates resources when capacity is exceeded. We'll add an option to compile a ",(0,o.jsx)(n.code,{children:"__copy"})," method that performs a deepcopy of the resource."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"DynamicVector"}),": A dynamically sized container that allocates a single chunk of heap memory without reallocation. It provides element access and supports a user-defined cast from a ",(0,o.jsx)(n.code,{children:"DynamicStack"})," for resource transfer. We'll add an option to compile a ",(0,o.jsx)(n.code,{children:"__copy"})," method that performs a deepcopy of the resource."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"VectorPair"}),": An aggregate type combining two Dynamic Vectors, with element access to its paired components."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Our focus is on the two ways of ownership transfer:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Move semantics: how resources are transferred efficiently by default, ensuring single ownership without unnecessary copying."}),"\n",(0,o.jsxs)(n.li,{children:["Value semantics: How to make a type copyable by implementing a ",(0,o.jsx)(n.code,{children:"__copy"})," method"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Let\u2019s dive in and see these concepts in action!"}),"\n",(0,o.jsx)(n.h2,{id:"tutorial-setup",children:"Tutorial setup"}),"\n",(0,o.jsxs)(n.p,{children:["You can either download the tutorial files ",(0,o.jsx)(n.a,{href:"https://github.com/simkinetic/tutorial-resource-management.git",children:"here"})," or follow along. We'll consider the following directory structure:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-plaintext",children:"/tutorial-move-semantics/\n  \u251c\u2500\u2500 libtutorial.t\n  \u251c\u2500\u2500 tutorial.t\n  \u2514\u2500\u2500 utils.t\n"})}),"\n",(0,o.jsxs)(n.p,{children:["First we'll write a small library for logging and checking asserts. Put the code below in a file ",(0,o.jsx)(n.code,{children:"utils.t"}),". Note how easy it is to simply hijack C-functions you are familiar with."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/utils.t start=utils_start end=utils_end",children:'local C = terralib.includecstring [[\n    #include <stdio.h>\n    #include <stdlib.h>\n]]\n\nlocal ffi = require("ffi")\n\nlocal S = {}\n\nS.error = macro(function(expr, msg)\n    local tree = expr.tree\n    local filename = tree.filename\n    local linenumber = tree.linenumber\n    local offset = tree.offset\n    local loc = filename .. ":" .. linenumber .. "+" .. offset\n    return quote\n        terralib.debuginfo(filename, linenumber)\n        C.printf("%s: %s\\n", loc, msg)\n        escape\n            --traceback currently does not work on macos\n            if ffi.os == "Linux" then\n                emit quote terralib.traceback(nil) end\n            end\n        end\n        C.abort()\n    end\nend)\n\nS.assert = macro(function(condition)\n    return quote\n        if not condition then\n            S.error(condition, "assertion failed!")\n        end\n    end\nend)\n\nS.printf = C.printf\n\nreturn S\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The implementation of the dynamic stack, vector and vector pair will be added to a ",(0,o.jsx)(n.code,{children:"libtutorial.t"})," file."]}),"\n",(0,o.jsx)(n.h2,{id:"implementation-of-a-dynamic-stack",children:"Implementation of a dynamic stack"}),"\n",(0,o.jsxs)(n.p,{children:["Let\u2019s kick off with ",(0,o.jsx)(n.code,{children:"DynamicStack"}),". This dynamic, heap-allocated container supports element access via ",(0,o.jsx)(n.code,{children:"stack(i)"}),", along with push and pop methods. It automatically reallocates when capacity is exceeded. By defining only ",(0,o.jsx)(n.code,{children:"__init"})," and ",(0,o.jsx)(n.code,{children:"__dtor"}),", we leverage Terra\u2019s auto-generated ",(0,o.jsx)(n.code,{children:"__move"})," for efficient resource transfers, enforcing move-only behavior without copying\u2014a perfect entry point to understanding Terra\u2019s default ownership and resource management. We'll conditionally compile a ",(0,o.jsx)(n.code,{children:"__copy"})," method that enables copyability like ordinary values."]}),"\n",(0,o.jsx)(n.p,{children:"Some general remarks are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Library Support: Load ",(0,o.jsx)(n.code,{children:"terralibext"})," for memory management and C\u2019s ",(0,o.jsx)(n.code,{children:"stdlib"})," via    ",(0,o.jsx)(n.code,{children:'terralib.includec("stdlib.h")'}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["The Lua function ",(0,o.jsx)(n.code,{children:"terralib.memoize"})," enables caching of the definition ",(0,o.jsx)(n.code,{children:"DynamicStack(T)"})," for element type ",(0,o.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Static Methods:",(0,o.jsx)(n.code,{children:"Stack.metamethods.__getmethod"})," simplifies static method access, enabling calls like ",(0,o.jsx)(n.code,{children:"Stack.new"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Element Access: ",(0,o.jsx)(n.code,{children:"Stack.metamethods.__apply"}),", a macro, enables ",(0,o.jsx)(n.code,{children:"stack(i)"})," for both get/set access."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Memory Management Notes"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["C Integration: Uses ",(0,o.jsx)(n.code,{children:"malloc"}),", ",(0,o.jsx)(n.code,{children:"realloc"}),", and ",(0,o.jsx)(n.code,{children:"free"})," from C\u2019s ",(0,o.jsx)(n.code,{children:"stdlib"})," for heap management."]}),"\n",(0,o.jsxs)(n.li,{children:["Move Semantics: ",(0,o.jsx)(n.code,{children:"push"})," and ",(0,o.jsx)(n.code,{children:"pop"})," use ",(0,o.jsx)(n.code,{children:"__move__"})," to transfer resources via a type\u2019s ",(0,o.jsx)(n.code,{children:"__move"})," method (if defined), avoiding copies."]}),"\n",(0,o.jsxs)(n.li,{children:["Implementation: Implements ",(0,o.jsx)(n.code,{children:"__init"})," and ",(0,o.jsx)(n.code,{children:"__dtor"}),"; ",(0,o.jsx)(n.code,{children:"__move"})," is auto-generated, making the stack movable but not copyable by default."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/libtutorial.t start=dynamic_stack_start end=dynamic_stack_end",children:'local DynamicStack = terralib.memoize(function(T, copyable)\n\n    local struct Stack {\n        data : &T       -- Pointer to heap-allocated elements\n        size : int      -- Current number of elements\n        capacity : int  -- Maximum capacity before reallocation\n    }\n\n    -- This table stores all the static methods\n    Stack.staticmethods = {}\n\n    -- Enable static method dispatch (e.g., Stack.new)\n    Stack.metamethods.__getmethod = function(self, methodname)\n        return self.methods[methodname] or Stack.staticmethods[methodname]\n    end\n\n    terra Stack:size() return self.size end\n    terra Stack:capacity() return self.capacity end\n\n    -- Macro for get/set access: stack(i)\n    Stack.metamethods.__apply = macro(function(self, i)\n        return `self.data[i]\n    end)\n\n    -- Initialize with null pointer and zero size/capacity\n    terra Stack:__init()\n        self.data = nil\n        self.size = 0\n        self.capacity = 0\n    end\n\n    -- Free heap memory and reset state\n    terra Stack:__dtor()\n        if self.data~=nil then\n            utils.printf("Deleting DynamicStack.\\n")\n            C.free(self.data)\n            self.data = nil\n        end\n    end\n\n    -- stack_copy_start\n    --conditional compilation, adding a __copy method to provide value-semantics\n    if copyable then\n        --deepcopy of Stack data structure\n        terra Stack.methods.__copy(from : &Stack, to : &Stack)\n            utils.printf("Copying DynamicStack.\\n")\n            to:__dtor() --delete old memory, just in case\n            to.data = [&T](C.malloc(from.capacity * sizeof(T))) --allocate new memory\n            C.memcpy(to.data, from.data, from.size * sizeof(T)) --copy data over\n            to.size, to.capacity =  from.size, from.capacity --set new size and capacity\n        end\n    end\n    -- stack_copy_end\n\n    -- Create a new stack with initial capacity\n    Stack.staticmethods.new = terra(capacity : int)\n        return Stack{data=[&T](C.malloc(capacity * sizeof(T))), capacity=capacity}\n    end\n\n    -- Reallocate when capacity is exceeded\n    terra Stack:realloc(capacity : int)\n        utils.printf("Reallocating DynamicStack.\\n")\n        self.data = [&T](C.realloc(self.data, capacity * sizeof(T)))\n        self.capacity = capacity\n    end\n\n    -- Push an element, moving it into the stack\n    terra Stack:push(v : T)\n        if self.size == self.capacity then\n            self:realloc(1 + 2 * self.capacity) -- Double capacity plus one\n        end\n        self.size = self.size + 1\n        self.data[self.size - 1] = __move__(v) -- Explicit move, avoiding copy when `v` is managed and copyable\n    end\n\n    -- Pop an element, moving it out\n    terra Stack:pop()\n        if self.size > 0 then\n            var tmp = __move__(self.data[self.size - 1]) -- Explicit move, cleaning resources of Stack element in case `T` is managed\n            self.size = self.size - 1\n            return tmp\n        end\n    end\n\n    return Stack\nend)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Important to understand is that the ",(0,o.jsx)(n.code,{children:"__copy"})," method is conditionally compiled. When ",(0,o.jsx)(n.code,{children:"copyable = false"})," the default behavior is to move data when passing by value to functions. When ",(0,o.jsx)(n.code,{children:"copyable = true"})," the ",(0,o.jsx)(n.code,{children:"__copy"})," method is compiled which enables deepcopying of data when passing arguments by value to functions."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/libtutorial.t start=stack_copy_start end=stack_copy_end",children:'--conditional compilation, adding a __copy method to provide value-semantics\nif copyable then\n    --deepcopy of Stack data structure\n    terra Stack.methods.__copy(from : &Stack, to : &Stack)\n        utils.printf("Copying DynamicStack.\\n")\n        to:__dtor() --delete old memory, just in case\n        to.data = [&T](C.malloc(from.capacity * sizeof(T))) --allocate new memory\n        C.memcpy(to.data, from.data, from.size * sizeof(T)) --copy data over\n        to.size, to.capacity =  from.size, from.capacity --set new size and capacity\n    end\nend\n'})}),"\n",(0,o.jsx)(n.h2,{id:"implementation-of-a-dynamic-vector",children:"Implementation of a dynamic vector"}),"\n",(0,o.jsxs)(n.p,{children:["Next, we\u2019ll implement ",(0,o.jsx)(n.code,{children:"DynamicVector"}),", a fixed-size, heap-allocated container. Unlike ",(0,o.jsx)(n.code,{children:"DynamicStack"}),", it doesn\u2019t reallocate, maintaining a single memory chunk. It supports element access with ",(0,o.jsx)(n.code,{children:"vector(i)"})," and introduces a user-defined cast from ",(0,o.jsx)(n.code,{children:"DynamicStack"})," to transfer resources efficiently. An auto-generated ",(0,o.jsx)(n.code,{children:"__move"})," ensures move-only behavior by default. An optional ",(0,o.jsx)(n.code,{children:"__copy"})," method makes the type copyable."]}),"\n",(0,o.jsxs)(n.p,{children:["The same general remarks apply as for the ",(0,o.jsx)(n.code,{children:"DynamicStack"})," implementation. C's ",(0,o.jsx)(n.code,{children:"malloc"}),", ",(0,o.jsx)(n.code,{children:"realloc"})," and ",(0,o.jsx)(n.code,{children:"free"})," are used to allocate, reallocate, and deallocate resources, respectively."]}),"\n",(0,o.jsx)(n.p,{children:"Specific notes on memory management are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Move Semantics: The ",(0,o.jsx)(n.code,{children:"__cast"})," metamethod reinterpretes a reference to a stack as a reference to a vector. Paired with an auto-generated move method ",(0,o.jsx)(n.code,{children:"__move :: {&Vector, &Vector} -> {}"})," it enables moving from a stack into a vector object."]}),"\n",(0,o.jsxs)(n.li,{children:["Implementation: Implements ",(0,o.jsx)(n.code,{children:"__init"})," and ",(0,o.jsx)(n.code,{children:"__dtor"}),"; ",(0,o.jsx)(n.code,{children:"__move"})," is auto-generated, ensuring movability without copyability by default."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/libtutorial.t start=dynamic_vector_start end=dynamic_vector_end",children:'local DynamicVector = terralib.memoize(function(T, copyable)\n\n    local struct Vector {\n        data : &T   -- Pointer to fixed heap memory\n        size : int  -- Number of elements\n    }\n\n    -- This table stores all the static methods\n    Vector.staticmethods = {}\n\n    -- Enable static method dispatch (e.g., Vector.new)\n    Vector.metamethods.__getmethod = function(self, methodname)\n        return self.methods[methodname] or Vector.staticmethods[methodname]\n    end\n\n    -- Initialize with null pointer and zero size\n    terra Vector:__init()\n        self.data = nil\n        self.size = 0\n    end\n\n    -- Free heap memory and reset\n    terra Vector:__dtor()\n        if self.data~=nil then\n            utils.printf("Deleting DynamicVector.\\n")\n            C.free(self.data)\n            self.data = nil\n            self.size = 0\n        end\n    end\n\n    -- vector_copy_start\n    --conditional compilation, adding a __copy method to provide value-semantics\n    if copyable then\n        --deepcopy of Vector data structure\n        terra Vector.methods.__copy(from : &Vector, to : &Vector)\n            utils.printf("Copying DynamicVector.\\n")\n            to:__dtor() --delete old memory, just in case\n            to.data = [&T](C.malloc(from.size * sizeof(T))) --allocate new memory\n            C.memcpy(to.data, from.data, from.size * sizeof(T)) --copy data over\n            to.size =  from.size --set new size\n        end\n    end\n    -- vector_copy_end\n\n    terra Vector:size() return self.size end\n\n    -- Macro for get/set access: vector(i)\n    Vector.metamethods.__apply = macro(function(self, i)\n        return `self.data[i]\n    end)\n\n    -- Allocate a dynamic vector of `size`\n    Vector.staticmethods.new = terra(size : int)\n        return Vector{data=[&T](C.malloc(size * sizeof(T))), size=size}\n    end\n\n    -- Import DynamicStack for casting\n    local Stack = DynamicStack(T, copyable)\n\n    -- Reinterprete a reference to a stack to a reference of a vector. This is for example used in `__move :: {&Vector, &Vector}` when one of the arguments is a pointer to a stack\n    Vector.metamethods.__cast = function(from, to, exp)\n        if from:ispointer() and from.type == Stack and to:ispointer() and to.type == Vector then\n            return quote\n                exp.capacity = 0 -- Invalidate Stack\u2019s ownership\n            in\n                [&Vector](exp) -- Transfer to &Vector, preps for `__move :: {&Vector, &Vector} -> {}`\n            end\n        else\n            error("ArgumentError: not able to cast " .. tostring(from) .. " to " .. tostring(to) .. ".")\n        end\n    end\n\n    return Vector\nend)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["As for the stack, conditional compilation of a ",(0,o.jsx)(n.code,{children:"__copy"})," method enables deepcopying of vectors when passing to functions by value."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/libtutorial.t start=vector_copy_start end=vector_copy_end",children:'--conditional compilation, adding a __copy method to provide value-semantics\nif copyable then\n    --deepcopy of Vector data structure\n    terra Vector.methods.__copy(from : &Vector, to : &Vector)\n        utils.printf("Copying DynamicVector.\\n")\n        to:__dtor() --delete old memory, just in case\n        to.data = [&T](C.malloc(from.size * sizeof(T))) --allocate new memory\n        C.memcpy(to.data, from.data, from.size * sizeof(T)) --copy data over\n        to.size =  from.size --set new size\n    end\nend\n'})}),"\n",(0,o.jsx)(n.h2,{id:"implementation-of-vectorpair",children:"Implementation of VectorPair"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"VectorPair"})," is an aggregate datastructure of two ",(0,o.jsx)(n.code,{children:"DynamicVector"}),"'s. Since ",(0,o.jsx)(n.code,{children:"DynamicVector"})," is a managed type, ",(0,o.jsx)(n.code,{children:"VectorPair"})," is too. It's ",(0,o.jsx)(n.code,{children:"__init"}),", ",(0,o.jsx)(n.code,{children:"__move"}),", and ",(0,o.jsx)(n.code,{children:"__dtor"})," method will be auto-generated."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/libtutorial.t start=dynamic_vector_pair_start end=dynamic_vector_pair_end",children:'local VectorPair = terralib.memoize(function(T, options)\n\n    local Vector = DynamicVector(T, options)\n\n    local struct Pair {\n        first : Vector\n        second : Vector\n    }\n\n    -- This table stores all the static methods\n    Pair.staticmethods = {}\n\n    -- Enable static method dispatch (e.g., Pair.new)\n    Pair.metamethods.__getmethod = function(self, methodname)\n        return self.methods[methodname] or Pair.staticmethods[methodname]\n    end\n\n    -- Create a new `DynamicVectorPair`. Note that the function arguments are passed by value. \n    -- If `Vector` implement `__copy`, the function argumens will be copied and otherwise moved.\n    -- Note how the `__move__` directive avoids potential copies.\n    Pair.staticmethods.new = terra(first : Vector, second : Vector)\n        utils.assert(first:size() == second:size(), "Error: sizes are not compatible.")\n        -- pair_new_start\n        return Pair{first=__move__(first), second=__move__(second)}\n        -- pair_new_end\n    end\n\n    -- Macro for get/set access: dualvector(i)\n    Pair.metamethods.__apply = macro(function(self, i)\n        return quote\n        in\n            self.first(i), self.second(i)\n        end\n    end)\n\n    terra Pair:size() return self.first:size() end\n\n    return Pair\nend)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In particular note the ",(0,o.jsx)(n.code,{children:"__move__"})," directives in the following line:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/libtutorial.t start=pair_new_start end=pair_new_end",children:"return Pair{first=__move__(first), second=__move__(second)}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"__move__"})," directive tells the compiler to use the ",(0,o.jsx)(n.code,{children:"__move"})," method rather than a ",(0,o.jsx)(n.code,{children:"__copy"})," (if it is implemented), avoiding any potential copies."]}),"\n",(0,o.jsx)(n.h2,{id:"example-use-case",children:"Example use-case"}),"\n",(0,o.jsx)(n.p,{children:"Consider next the following application code where the data structures are combined. We'll highlight where moves or copies are taking place"}),"\n",(0,o.jsxs)(r.x,{children:[(0,o.jsxs)(r.c,{title:"Move-semantics",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/tutorial-move.t start=tutorial_start end=tutorial_end",children:"local utils = require(\"utils\")\nlocal lib = require(\"libtutorial\")\n\nlocal copyable = false\nlocal Stack = lib.DynamicStack(int, copyable)\nlocal Vector = lib.DynamicVector(int, copyable)\nlocal VectorPair = lib.VectorPair(int, copyable)\n\nterra main()\n    -- create a stack and push some data\n    var s = Stack.new(3)\n    utils.printf(\"Adding three elements to 's'.\\n\")\n    s:push(1)\n    s:push(2)\n    s:push(3)\n    utils.printf(\"Adding two more elements to 's'.\\n\")\n    s:push(4) --reallocating here\n    s:push(5)\n\n    -- move contents of `s` into a Vector\n    utils.printf(\"Move 's' -> 'v'\\n\")\n    utils.assert(s:size() == 5)\n    var v : Vector = s\n    utils.assert(s:size() == 0)\n    utils.assert(v:size() == 5)\n\n    -- create another stack and push some data\n    var t = Stack.new(5)\n    t:push(1)\n    t:push(2)\n    t:push(3)\n    t:push(2)\n    t:push(1)\n\n    -- move contents of `t` into a Vector\n    utils.printf(\"Move 't' -> 'w'\\n\")\n    utils.assert(t:size() == 5)\n    var w : Vector = t\n    utils.assert(t:size() == 0)\n    utils.assert(w:size() == 5)\n\n    -- move contents of vector v, w into the aggregate data-structure\n    utils.printf(\"Move '(v, w)' -> 'dual'\\n\")\n    var dual = VectorPair.new(v, w)\n    utils.assert(dual:size() == 5)\n    utils.assert(v:size() == 0 and w:size() == 0)\n\n    -- print contents of aggregate data type\n    utils.printf(\"Contents of 'dual':\\n\")\n    for i=0,5 do\n        var x, y = dual(i)\n        utils.printf(\"  dual(%d) = (%d, %d)\\n\", i, x, y)\n    end \n\nend\n\nmain()\n"})}),(0,o.jsxs)(n.p,{children:["If you run this example - with ",(0,o.jsx)(n.code,{children:"copyable=true"})," - then you should see the following output. Note that the data is moved several times:"]}),(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["first from stack ",(0,o.jsx)(n.code,{children:"s"})," and ",(0,o.jsx)(n.code,{children:"t"})," to vectors ",(0,o.jsx)(n.code,{children:"v"})," and ",(0,o.jsx)(n.code,{children:"w"}),", respectively;"]}),"\n",(0,o.jsxs)(n.li,{children:["then from ",(0,o.jsx)(n.code,{children:"v"})," and ",(0,o.jsx)(n.code,{children:"w"})," into the aggregate variable ",(0,o.jsx)(n.code,{children:"dual"}),";"]}),"\n"]}),(0,o.jsxs)(n.p,{children:["Finally, the two components of ",(0,o.jsx)(n.code,{children:"dual"})," are deleted."]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Adding three elements to 's'.\nAdding two more elements to 's'.\nReallocating DynamicStack.\nMove 's' -> 'v'\nMove 't' -> 'w'\nMove '(v, w)' -> 'dual'\nContents of 'dual':\n  dual(0) = (1, 1)\n  dual(1) = (2, 2)\n  dual(2) = (3, 3)\n  dual(3) = (4, 2)\n  dual(4) = (5, 1)\nDeleting DynamicVector.\nDeleting DynamicVector.\n"})})]}),(0,o.jsxs)(r.c,{title:"Value-semantics",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-terra",metastring:"file=./tutorials/tutorial-resource-management/tutorial-copy.t start=tutorial_start end=tutorial_end",children:"local utils = require(\"utils\")\nlocal lib = require(\"libtutorial\")\n\nlocal copyable = true\nlocal Stack = lib.DynamicStack(int, copyable)\nlocal Vector = lib.DynamicVector(int, copyable)\nlocal VectorPair = lib.VectorPair(int, copyable)\n\nterra main()\n    -- create a stack and push some data\n    var s = Stack.new(3)\n    utils.printf(\"Adding three elements to 's'.\\n\")\n    s:push(1)\n    s:push(2)\n    s:push(3)\n    utils.printf(\"Adding two more elements to 's'.\\n\")\n    s:push(4) --reallocating here\n    s:push(5)\n\n    -- copy contents of `s` into a Vector\n    utils.printf(\"Copy 's' -> 'v'\\n\")\n    utils.assert(s:size() == 5)\n    var v : Vector = s\n    utils.assert(s:size() == 5)\n    utils.assert(v:size() == 5)\n\n    -- create another stack and push some data\n    var t = Stack.new(5)\n    t:push(1)\n    t:push(2)\n    t:push(3)\n    t:push(2)\n    t:push(1)\n\n    -- copy contents of `t` into a Vector\n    utils.printf(\"Copy 't' -> 'w'\\n\")\n    utils.assert(t:size() == 5)\n    var w : Vector = t\n    utils.assert(t:size() == 5)\n    utils.assert(w:size() == 5)\n\n    -- copy contents of vector v, w into the aggregate data-structure\n    utils.printf(\"Copy '(v, w)' -> 'dual'\\n\")\n    var dual = VectorPair.new(v, w)\n    utils.assert(dual:size() == 5)\n    utils.assert(v:size() == 5 and w:size() == 5)\n\n    -- print contents of aggregate data type\n    utils.printf(\"Contents of 'dual':\\n\")\n    for i=0,5 do\n        var x, y = dual(i)\n        utils.printf(\"  dual(%d) = (%d, %d)\\n\", i, x, y)\n    end \n\nend\n\nmain()\n"})}),(0,o.jsxs)(n.p,{children:["If you run this example - with ",(0,o.jsx)(n.code,{children:"copyable=true"})," - then you should see the following output. The data is copied several times:"]}),(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["first from stack ",(0,o.jsx)(n.code,{children:"s"})," and ",(0,o.jsx)(n.code,{children:"t"})," to vectors ",(0,o.jsx)(n.code,{children:"v"})," and ",(0,o.jsx)(n.code,{children:"w"}),", respectively;"]}),"\n",(0,o.jsxs)(n.li,{children:["then from ",(0,o.jsx)(n.code,{children:"v"})," and ",(0,o.jsx)(n.code,{children:"w"})," into the aggregate variable ",(0,o.jsx)(n.code,{children:"dual"}),";"]}),"\n"]}),(0,o.jsxs)(n.p,{children:["Finally, ",(0,o.jsx)(n.code,{children:"s"}),", ",(0,o.jsx)(n.code,{children:"t"})," and ",(0,o.jsx)(n.code,{children:"v"}),", ",(0,o.jsx)(n.code,{children:"w"})," and the two components of ",(0,o.jsx)(n.code,{children:"dual"})," are deleted."]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Adding three elements to 's'.\nAdding two more elements to 's'.\nReallocating DynamicStack.\nCopy 's' -> 'v'\nCopying DynamicVector.\nCopy 't' -> 'w'\nCopying DynamicVector.\nCopy '(v, w)' -> 'dual'\nCopying DynamicVector.\nCopying DynamicVector.\nContents of 'dual':\n  dual(0) = (1, 1)\n  dual(1) = (2, 2)\n  dual(2) = (3, 3)\n  dual(3) = (4, 2)\n  dual(4) = (5, 1)\nDeleting DynamicVector.\nDeleting DynamicVector.\nDeleting DynamicVector.\nDeleting DynamicStack.\nDeleting DynamicVector.\nDeleting DynamicStack.\n"})})]})]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},4853:(e,n,t)=>{t.d(n,{c:()=>i,x:()=>o});t(6540);var a=t(4848);const o=e=>{let{children:n}=e;return(0,a.jsx)("div",{style:{display:"flex",gap:"1rem",flexWrap:"wrap"},children:n})},i=e=>{let{children:n,title:t}=e;return(0,a.jsxs)("div",{style:{flex:1,minWidth:"300px"},children:[t&&(0,a.jsx)("div",{style:{color:"var(--ifm-font-color-base)",padding:"0.5rem 1rem",borderRadius:"var(--ifm-pre-border-radius, 4px) var(--ifm-pre-border-radius, 4px) 0 0",borderBottom:"none",fontSize:"0.9rem",fontWeight:"bold"},children:t}),(0,a.jsx)("div",{style:{marginTop:t?"0":"inherit",borderRadius:t?"0 0 var(--ifm-pre-border-radius, 4px) var(--ifm-pre-border-radius, 4px)":"var(--ifm-pre-border-radius, 4px)",overflow:"hidden"},children:n})]})}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var a=t(6540);const o={},i=a.createContext(o);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);