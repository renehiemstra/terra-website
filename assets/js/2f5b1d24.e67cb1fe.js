"use strict";(self.webpackChunkterra_website=self.webpackChunkterra_website||[]).push([[2739],{5084:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"Getting started","items":[{"type":"link","label":"Installing and setting up Terra","href":"/terra-website/docs/getting-started/install-and-setup","docId":"getting-started/install-and-setup","unlisted":false},{"type":"link","label":"Your first programm","href":"/terra-website/docs/getting-started/your-first-program","docId":"getting-started/your-first-program","unlisted":false},{"type":"link","label":"Terra for C / C++ programmers","href":"/terra-website/docs/getting-started/terra-for-cpp","docId":"getting-started/terra-for-cpp","unlisted":false}],"collapsed":true,"collapsible":true,"href":"/terra-website/docs/getting-started/intro"},{"type":"category","label":"Core language","collapsed":false,"items":[{"type":"category","label":"Metaprogramming","items":[{"type":"link","label":"A first example","href":"/terra-website/docs/core-language/metaprogramming/hello-world","docId":"core-language/metaprogramming/hello-world","unlisted":false}],"collapsed":true,"collapsible":true,"href":"/terra-website/docs/core-language/metaprogramming/intro"},{"type":"category","label":"Resource management","items":[{"type":"link","label":"Core concepts","href":"/terra-website/docs/core-language/resource-management/core-concepts","docId":"core-language/resource-management/core-concepts","unlisted":false},{"type":"link","label":"Ownership model","href":"/terra-website/docs/core-language/resource-management/ownership-model","docId":"core-language/resource-management/ownership-model","unlisted":false},{"type":"link","label":"Comparisons with C++ and Rust","href":"/terra-website/docs/core-language/resource-management/comparison","docId":"core-language/resource-management/comparison","unlisted":false},{"type":"link","label":"Tutorial - Value versus Move Semantics","href":"/terra-website/docs/core-language/resource-management/tutorial/move-vs-value","docId":"core-language/resource-management/tutorial/move-vs-value","unlisted":false}],"collapsed":true,"collapsible":true,"href":"/terra-website/docs/core-language/resource-management/intro"}],"collapsible":true,"href":"/terra-website/docs/core-language/intro"},{"type":"category","label":"Standard Library","collapsed":false,"items":[{"type":"category","label":"Allocators","items":[{"type":"link","label":"Allocator base class design","href":"/terra-website/docs/standard-library/allocators/design","docId":"standard-library/allocators/design","unlisted":false},{"type":"link","label":"A smart memory block","href":"/terra-website/docs/standard-library/allocators/memory-block","docId":"standard-library/allocators/memory-block","unlisted":false},{"type":"link","label":"Allocator interface","href":"/terra-website/docs/standard-library/allocators/interface","docId":"standard-library/allocators/interface","unlisted":false},{"type":"link","label":"Custom Allocators","href":"/terra-website/docs/standard-library/allocators/custom-allocators","docId":"standard-library/allocators/custom-allocators","unlisted":false}],"collapsed":true,"collapsible":true,"href":"/terra-website/docs/standard-library/allocators/intro"},{"type":"link","label":"Concepts","href":"/terra-website/docs/standard-library/concepts/intro","docId":"standard-library/concepts/intro","unlisted":false},{"type":"link","label":"Ranges","href":"/terra-website/docs/standard-library/ranges/intro","docId":"standard-library/ranges/intro","unlisted":false},{"type":"link","label":"Containers","href":"/terra-website/docs/standard-library/containers/intro","docId":"standard-library/containers/intro","unlisted":false},{"type":"link","label":"Linear algebra","href":"/terra-website/docs/standard-library/linalg/intro","docId":"standard-library/linalg/intro","unlisted":false},{"type":"link","label":"Treads","href":"/terra-website/docs/standard-library/threads/intro","docId":"standard-library/threads/intro","unlisted":false},{"type":"category","label":"Unit-testing","items":[{"type":"link","label":"Writing and evaluating tests","href":"/terra-website/docs/standard-library/unit-testing/writing-tests","docId":"standard-library/unit-testing/writing-tests","unlisted":false},{"type":"link","label":"Test-environments","href":"/terra-website/docs/standard-library/unit-testing/organizing-tests-testenv","docId":"standard-library/unit-testing/organizing-tests-testenv","unlisted":false},{"type":"link","label":"Test-sets","href":"/terra-website/docs/standard-library/unit-testing/organizing-tests-testset","docId":"standard-library/unit-testing/organizing-tests-testset","unlisted":false},{"type":"link","label":"Parameterized testing","href":"/terra-website/docs/standard-library/unit-testing/parameterized-tests","docId":"standard-library/unit-testing/parameterized-tests","unlisted":false},{"type":"link","label":"Parallel test-runner","href":"/terra-website/docs/standard-library/unit-testing/parallel-test-suites","docId":"standard-library/unit-testing/parallel-test-suites","unlisted":false}],"collapsed":true,"collapsible":true,"href":"/terra-website/docs/standard-library/unit-testing/intro"},{"type":"link","label":"Managing dependencies","href":"/terra-website/docs/standard-library/package-managing/intro","docId":"standard-library/package-managing/intro","unlisted":false}],"collapsible":true,"href":"/terra-website/docs/standard-library/intro"}]},"docs":{"core-language/intro":{"id":"core-language/intro","title":"intro","description":"","sidebar":"tutorialSidebar"},"core-language/metaprogramming/hello-world":{"id":"core-language/metaprogramming/hello-world","title":"A first example","description":"We begin with metaprogramming in terra by reproducing the C example from","sidebar":"tutorialSidebar"},"core-language/metaprogramming/intro":{"id":"core-language/metaprogramming/intro","title":"Introduction into metaproramming","description":"Starting with C, many programming languages have support for multistage","sidebar":"tutorialSidebar"},"core-language/resource-management/comparison":{"id":"core-language/resource-management/comparison","title":"Comparisons with C++ and Rust","description":"Terra\u2019s resource management system harmonizes C++\u2019s control with Rust\u2019s ownership principles, emphasizing both simplicity and efficiency. Compared to C++, Terra forgoes certain flexibilities, such as constructors, in favor of a concise Rule of Three (init, copy, dtor) characterized by simple and safe rules. It enhances performance over C++ for R-values by consistently employing a bitwise copy (memcpy), avoiding C++\u2019s potential for implicit copying or dependence on optimizations.","sidebar":"tutorialSidebar"},"core-language/resource-management/core-concepts":{"id":"core-language/resource-management/core-concepts","title":"Core concepts","description":"Below we summarize the core concepts and rules relevant to resource management in Terra. These concepts will be explained in greater detail in the next sections.","sidebar":"tutorialSidebar"},"core-language/resource-management/intro":{"id":"core-language/resource-management/intro","title":"Resource management in Terra","description":"Resource management is a critical aspect of programming languages, and Terra\u2019s new system blends C++\u2019s flexibility with Rust\u2019s ownership principles to deliver safe, efficient defaults while unlocking its metaprogramming potential. In the sections that follow, we\u2019ll explore the core concepts, ownership model, key methods, and practical tutorials\u2014from basic data structures to advanced integrations\u2014showcasing how Terra balances performance, safety, and adaptability.","sidebar":"tutorialSidebar"},"core-language/resource-management/ownership-model":{"id":"core-language/resource-management/ownership-model","title":"Ownership model","description":"Terra\u2019s ownership model ensures every resource has exactly one owner at any time, akin to Rust\u2019s single-ownership principle, preventing data races, dangling pointers, and double-free errors. This model guarantees safety in sequential and shared memory parallel contexts through strict resource transfer and access rules.","sidebar":"tutorialSidebar"},"core-language/resource-management/raii":{"id":"core-language/resource-management/raii","title":"Deterministic Automated Resource Management","description":"Resource management in programming languages generally falls into one of the following categories:"},"core-language/resource-management/tutorial/move-vs-value":{"id":"core-language/resource-management/tutorial/move-vs-value","title":"Tutorial - Value versus Move Semantics","description":"In this tutorial, we explore Terra\u2019s resource management system through the lens of value and move semantics. The default approach to resource management is to move resources when they are passed by value to a function or used in an assignment. Value semantics - where resources behave more like regular values - is simply achieved by implementing a copy method where you, as the programmer, are in control of how values are copied.","sidebar":"tutorialSidebar"},"features/backwards-compatible-with-c":{"id":"features/backwards-compatible-with-c","title":"Backwards compatible with C","description":""},"features/domain-specific-languages":{"id":"features/domain-specific-languages","title":"Build your own DSL","description":"Domain-Specific Languages (DSLs) are specialized programming languages crafted to tackle specific types of problems\u2014think image processing, physical simulations, or financial modeling\u2014without the complexity of general-purpose languages like Python, Terra or C++. By focusing on what matters most in your field, DSLs streamline workflows, boost productivity, and bridge the gap between technical experts and domain specialists."},"features/exascale-computing":{"id":"features/exascale-computing","title":"Terra-Regent: Task-based parallelism for distributed workloads","description":""},"features/multistage-programming":{"id":"features/multistage-programming","title":"Multistage programming","description":"Multistage programming is a cornerstone of Terra\'s design, enabling developers to write code that generates and specializes other code at compile-time. By treating Terra\'s functions, types, variables, and expressions as first-class values in Lua, multistage programming allows for dynamic code construction, optimization, and specialization. This paradigm, rooted in the interplay between Lua\'s flexibility and Terra\'s high-performance compilation, empowers developers to create efficient, adaptive programs with minimal boilerplate."},"features/powerful-standard-library":{"id":"features/powerful-standard-library","title":"Powerful standard library","description":"Allocators"},"features/script-with-c-performance":{"id":"features/script-with-c-performance","title":"Script with C-performance","description":"Terra is a simple and expressive statically typed compiled language built on top of LuaJIT, the fastest JIT-compiler in the West. This unique combination allows Terra to deliver performance comparable to C while maintaining the flexibility and ease of a scripting language."},"features/tutorial/move-vs-value":{"id":"features/tutorial/move-vs-value","title":"Tutorial - Value versus Move Semantics","description":""},"getting-started/install-and-setup":{"id":"getting-started/install-and-setup","title":"Installing and setting up Terra","description":"Installing Terra","sidebar":"tutorialSidebar"},"getting-started/intro":{"id":"getting-started/intro","title":"intro","description":"","sidebar":"tutorialSidebar"},"getting-started/terra-for-cpp":{"id":"getting-started/terra-for-cpp","title":"Terra for C / C++ programmers","description":"Terra is a low-level, statically-typed language designed to interoperate seamlessly with Lua, offering semantics very similar to C/C++. However, its tight integration with Lua means that familiar C++ constructs are often expressed differently. This reference sheet bridges the gap by comparing C++ snippets with their Terra-Lua equivalents, helping C++ programmers transition to Terra. Where applicable, a third column illustrates how to meta-program these constructs using Lua\'s dynamic capabilities.","sidebar":"tutorialSidebar"},"getting-started/your-first-program":{"id":"getting-started/your-first-program","title":"Your first programm","description":"","sidebar":"tutorialSidebar"},"standard-library/allocators/custom-allocators":{"id":"standard-library/allocators/custom-allocators","title":"Custom Allocators","description":"Custom alloctors can be implemented easily by defining a new class that satisfies the low-level allocator interface. By calling a base class the allocator user-interface is automatically generated.","sidebar":"tutorialSidebar"},"standard-library/allocators/design":{"id":"standard-library/allocators/design","title":"Allocator base class design","description":"The overall design is based on the following key ideas:","sidebar":"tutorialSidebar"},"standard-library/allocators/interface":{"id":"standard-library/allocators/interface","title":"Allocator interface","description":"Allocators follow a simple design","sidebar":"tutorialSidebar"},"standard-library/allocators/intro":{"id":"standard-library/allocators/intro","title":"Allocators in Terra","description":"Allocators give developers the power to manage memory with precision, choosing where and how memory is allocated\u2014whether from the stack for quick, temporary objects or the heap for longer-lived data. This flexibility helps optimize performance, reduce memory fragmentation, and keep related data close together for faster access, which is crucial for high-performance applications.","sidebar":"tutorialSidebar"},"standard-library/allocators/memory-block":{"id":"standard-library/allocators/memory-block","title":"A smart memory block","description":"The allocator API is built around the abstraction of a memory block. Unlike traditional designs that store only a pointer to the allocated data, this approach encapsulates additional metadata","sidebar":"tutorialSidebar"},"standard-library/concepts/intro":{"id":"standard-library/concepts/intro","title":"Concept-based function overloading","description":"","sidebar":"tutorialSidebar"},"standard-library/containers/intro":{"id":"standard-library/containers/intro","title":"Containers","description":"","sidebar":"tutorialSidebar"},"standard-library/intro":{"id":"standard-library/intro","title":"Terra\'s Standard Library","description":"The Terra Standard Library is a comprehensive and well-engineered collection of tools designed to support robust software development in the Terra programming language. It provides a unified set of facilities that address critical aspects of programming, from resource management to advanced mathematical computation. The library is structured to offer both flexibility and efficiency, making it suitable for a wide range of applications, from system-level programming to high-performance computing and artificial intelligence workloads.","sidebar":"tutorialSidebar"},"standard-library/linalg/intro":{"id":"standard-library/linalg/intro","title":"Linear algebra","description":"","sidebar":"tutorialSidebar"},"standard-library/package-managing/intro":{"id":"standard-library/package-managing/intro","title":"Managing project dependencies","description":"Terra\u2019s package manager - Cosm along with its command-line interface cosm - is designed to make managing project dependencies easier when projects grow. It lets you install, manage, and share packages reliably, ensuring your builds are consistent every time. One cool feature is it doesn\u2019t need lockfiles, thanks to minimal version selection, which helps keep things reproducible. It\u2019s also easy to extend for new languages with simple plugins, and its Git-like CLI feels familiar if you\u2019re used to version control. Whether you\u2019re handling public or private package registries, Cosm is a handy tool for organizing dependencies and collaborating on complex projects.","sidebar":"tutorialSidebar"},"standard-library/ranges/intro":{"id":"standard-library/ranges/intro","title":"Ranges","description":"","sidebar":"tutorialSidebar"},"standard-library/threads/intro":{"id":"standard-library/threads/intro","title":"Shared-memory parallelism using Threads","description":"","sidebar":"tutorialSidebar"},"standard-library/unit-testing/intro":{"id":"standard-library/unit-testing/intro","title":"Unit-testing","description":"Terratest is a lightweight, intuitive unit-testing library designed specifically for the Terra programming language. Implemented as a language extension, it seamlessly integrates with Terra\'s hybrid Lua-Terra ecosystem, providing a simple yet powerful way to test small units of code. With just four constructs\u2014test, testenv, testset, and terracode\u2014it enables both inline assertions and organized test suites.","sidebar":"tutorialSidebar"},"standard-library/unit-testing/organizing-tests-testenv":{"id":"standard-library/unit-testing/organizing-tests-testenv","title":"Test-environments","description":"Although tests can be used directly inline as shown above, it is useful to organize them inside a scoped environment called testenv. This environement keeps track of some test statistics, which get printed to stdout. Here is an example","sidebar":"tutorialSidebar"},"standard-library/unit-testing/organizing-tests-testset":{"id":"standard-library/unit-testing/organizing-tests-testset","title":"Test-sets","description":"testset provides another scoped environment that can be used within a testenv. A testset is also given a name and test statistics are printed out separately for each testset inside a test environment. For example,","sidebar":"tutorialSidebar"},"standard-library/unit-testing/parallel-test-suites":{"id":"standard-library/unit-testing/parallel-test-suites","title":"Parallel test-runner","description":"","sidebar":"tutorialSidebar"},"standard-library/unit-testing/parameterized-tests":{"id":"standard-library/unit-testing/parameterized-tests","title":"Parameterized testing","description":"Consider the following Vector class:","sidebar":"tutorialSidebar"},"standard-library/unit-testing/writing-tests":{"id":"standard-library/unit-testing/writing-tests","title":"Writing and evaluating tests","description":"Tests may combine both lua and terra code. For example, the following code directly evaluates a lua statement","sidebar":"tutorialSidebar"},"tutorial-basics/congratulations":{"id":"tutorial-basics/congratulations","title":"Congratulations!","description":"You have just learned the basics of Docusaurus and made some changes to the initial template."},"tutorial-basics/create-a-blog-post":{"id":"tutorial-basics/create-a-blog-post","title":"Create a Blog Post","description":"Docusaurus creates a page for each blog post, but also a blog index page, a tag system, an RSS feed..."},"tutorial-basics/create-a-document":{"id":"tutorial-basics/create-a-document","title":"Create a Document","description":"Documents are groups of pages connected through:"},"tutorial-basics/create-a-page":{"id":"tutorial-basics/create-a-page","title":"Create a Page","description":"Add Markdown or React files to src/pages to create a standalone page:"},"tutorial-basics/deploy-your-site":{"id":"tutorial-basics/deploy-your-site","title":"Deploy your site","description":"Docusaurus is a static-site-generator (also called Jamstack)."},"tutorial-basics/markdown-features":{"id":"tutorial-basics/markdown-features","title":"Markdown Features","description":"Docusaurus supports Markdown and a few additional features."},"tutorial-extras/manage-docs-versions":{"id":"tutorial-extras/manage-docs-versions","title":"Manage Docs Versions","description":"Docusaurus can manage multiple versions of your docs."},"tutorial-extras/translate-your-site":{"id":"tutorial-extras/translate-your-site","title":"Translate your site","description":"Let\'s translate docs/intro.md to French."}}}}')}}]);