---
id: multistage-programming
title: Multistage programming
---

import { CodeColumns, CodeColumn } from '../../src/components/CodeColumns';

# Multistage programming
__Terra__ is a low-level system programming language that is embedded in and meta-programmed by the __Lua__ programming language:
```terra
--This top-level code is plain Lua code.
function printhello()
    -- This is a plain Lua function
    print("Hello, Lua!")
end
printhello()

-- Terra is backwards compatible with C, we'll use C's io library in our example.
C = terralib.includec("stdio.h")

-- The keyword 'terra' introduces a new Terra function.
terra hello(argc : int, argv : &rawstring)
    -- Here we call a C function from Terra
    C.printf("Hello, Terra!\n")
    return 0
end

-- You can call Terra functions directly from Lua, they are JIT compiled 
-- using LLVM to create machine code
hello(0,nil)

-- Terra functions are first-class values in Lua, and can be introspected 
-- and meta-programmed using it
hello:disas()
--[[ output:
    assembly for function at address 0x60e6010
    0x60e6010(+0):		push	rax
    0x60e6011(+1):		movabs	rdi, 102129664
    0x60e601b(+11):		movabs	rax, 140735712154681
    0x60e6025(+21):		call	rax
    0x60e6027(+23):		xor	eax, eax
    0x60e6029(+25):		pop	rdx
    0x60e602a(+26):		ret
]]

-- You can save Terra code as executables, object files, or shared libraries 
-- and link them into existing programs
terralib.saveobj("helloterra",{ main = hello })
```
Try this example and others in your browser via [Replit](https://replit.com/@terralang/terra).

Like C/C++, Terra is a  **statically-typed**, **compiled language** with manual memory management. 
But unlike C/C++, it is designed from the beginning to be **meta-programmed from Lua**. 

The design of Terra comes from the realization that C/C++ is really composed of multiple "languages." It has a core language of operators, control-flow, and functions calls, but surrounding this language is a meta-language composed of a mix of features such as the pre-processor, templating system, and struct definitions. Templates alone are Turing-complete and have been used to produce optimized libraries such as [Eigen](http://eigen.tuxfamily.org/index.php?title=Main_Page), but are horrible to use in practice. 

In Terra, we just gave in to the trend of making the meta-language of C/C++ more powerful and replaced it with a real programming language, Lua. 

The combination of a low-level language meta-programmed by a high-level scripting language allows many behaviors that are not possible in other systems. Unlike C/C++, Terra code can be JIT-compiled and run interleaved with Lua evaluation, making it easy to write software libraries that depend on runtime code generation. 

Features of other languages such as conditional compilation and templating simply fall out of the combination of using Lua to meta-program Terra:

<CodeColumns>
  <CodeColumn title="Terra">
    ```terra
    terra add(a : int,b : int) : int
        return a + b
    end
    ```
  </CodeColumn> 
  <CodeColumn title="C++"> 
    ```cpp
    int add(int a, int b) {
        return a + b;
    }
    ``` 
  </CodeColumn> 
</CodeColumns>
Conditional compilation is done with control-flow that determines what code is defined.
<CodeColumns>
  <CodeColumn>
    ```terra
    if iswindows() then
        terra waitatend()
            C.getchar()
        end
    else
        terra waitatend() end
    end
    ```
  </CodeColumn> 
  <CodeColumn> 
    ```cpp
    #ifdef _WIN32
        void waitatend() { 
            getchar(); 
        }
    #else
        void waitatend() {}
    #endif
    ``` 
  </CodeColumn> 
</CodeColumns>
Templates become Lua functions that take a terra type T and use it to generate new types and code.
<CodeColumns>
  <CodeColumn>
    ```terra
    function Array(T)
        struct Array {
            N : int
            data : &T
        }
        terra Array:get(i : int)
            return self.data[i]
        end
        return Array
    end

    FloatArray = Array(float)
    ```
  </CodeColumn> 
  <CodeColumn> 
    ```cpp
    template<class T>
    struct Array {
        int N;
        T* data;

        T get(int i) {
            return data[i];
        }

    };
    
    typedef Array<float> FloatArray;
    ``` 
  </CodeColumn> 
</CodeColumns>

## How can you use Terra?
Terra is a statically-typed, compiled language that interoperates seamlessly with Lua. In this setup, Lua acts as the high-level meta-programming layer, while Terra handles the low-level, performance-critical code. The two languages share a lexical environment, meaning Terra code is written within Lua programs, and Lua can dynamically generate and manipulate Terra code at runtime. You can use Terra and Lua in the followind way ...

### An embedded JIT-compiler for building languages
We use techniques from [multi-stage programming](https://en.wikipedia.org/wiki/Multi-stage_programming) to make it possible to  [meta-program](#generative-programming) Terra using Lua.  Terra expressions, types, and functions are all first-class Lua values, making it possible to generate arbitrary programs at runtime. This allows you to [compile domain-specific languages](#compiling-a-language) (DSLs) written in Lua into high-performance Terra code. Furthermore, since Terra is built on the Lua ecosystem, it is easy to [embed](#embedding-and-interoperability) Terra-Lua programs in other software as a library. This design allows you to add a JIT-compiler into your existing software. You can use it to add a JIT-compiled DSL to your application, or to auto-tune high-performance code dynamically.

### A scripting-language with high-performance extensions 
While the performance of Lua and other dynamic languages is always getting better, a low-level of abstraction gives you predictable control of performance when you need it. Terra programs use the same LLVM backend that Apple uses for its C compilers. This means that Terra code performs similarly to equivalent C code. Terra also includes built-in support for SIMD operations, and other low-level features like non-temporal writes and prefetches. You can use Lua to organize and configure your application, and then call into Terra code when you need controllable performance.

### A stand-alone low-level language 
Terra was designed so that it can run independently from Lua. In fact, if your final program doesn't need Lua, you can save Terra code into a .o file or executable. In addition to ensuring a clean separation between high- and low-level code, this design lets you use Terra as a stand-alone low-level language. In this use-case, Lua serves as a powerful meta-programming language.  Here it serves as a replacement for C++ [template metaprogramming](https://en.wikipedia.org/wiki/Template_metaprogramming) or C preprocessor [X-Macros](https://en.wikipedia.org/wiki/X_macro) with better syntax and nicer properties such as [hygiene](https://en.wikipedia.org/wiki/Hygienic_macro). Since Terra exists *only* as code embedded in a Lua meta-program, features that are normally built into low-level languages can be implemented as Lua libraries. This design keeps the core of Terra simple, while enabling powerful behavior such as conditional compilation, namespaces, templating, and even **class systems** **[implemented as libraries](#simplicity)**.


## Generative Programming {#generative-programming}
Placeholder text

## Compiling-a-language {#compiling-a-language}
Placeholder text

## Embedding-and-interoperability {#embedding-and-interoperability}
Placeholder text

## Simplicity (#simplicity)