---
id: multistage-programming
title: Multistage programming
---

import { CodeColumns, CodeColumn } from '../../src/components/CodeColumns';

# Multistage programming in Terra
Multistage programming lies at the heart of Terra's design, empowering developers to create code that dynamically generates and specializes other code at compile time. By elevating Terra's functions, types, variables, and expressions to first-class citizens within Lua, this approach facilitates seamless code construction, optimization, and adaptation.

Since Terra operates exclusively as code embedded within a Lua metaprogram, features traditionally hardcoded into low-level languages can instead be crafted as Lua libraries. This architecture maintains a lean core for Terra while unlocking robust capabilities, such as conditional compilation, namespaces, templating, and even class systems—all realized through libraries.

Rooted in the synergy between Lua's expressive flexibility and Terra's high-performance compilation, this paradigm enables developers to build efficient, adaptable programs with remarkably little boilerplate.

## Dynamic Code Generation
The design of Terra stems from the insight that C/C++ effectively comprises multiple "languages": a core language of operators, control flow, and function calls, surrounded by a fragmented meta-language including the preprocessor, templating system, and struct definitions. While C++ templates are Turing-complete and have enabled optimized libraries like Eigen, they are notoriously cumbersome in practice.

Terra embraces and extends this approach by replacing C/C++'s ad-hoc meta-language with a full-fledged programming language: Lua. This pairing of a low-level systems language with a high-level scripting language unlocks capabilities beyond traditional systems. Unlike C/C++, Terra code can be JIT-compiled and executed interleaved with Lua, simplifying the creation of libraries that rely on runtime code generation.

As a result, features from other languages—such as conditional compilation and templating—emerge organically from Lua's metaprogramming of Terra. For example, templated types, akin to C++ templates but far more flexible, arise through Lua's dynamic code generation, supporting parameterized structs and functions without rigid syntax. Arbitrary compile-time computations, like producing optimized kernels based on runtime parameters or domain-specific abstractions, become simple Lua scripts that seamlessly integrate high-performance Terra code with expressive metaprogramming.

Multistage programming further empowers Terra to dynamically generate code tailored to specific scenarios, such as functions optimized for input sizes, hardware targets, or constraints. This is invaluable for tasks like loop unrolling, constant folding, or SIMD vectorization, all orchestrated via Lua for efficient, adaptive execution.

<details>
  <summary>Example: Conditional compilation </summary>

Conditional compilation is done with control-flow that determines what code is defined.
<CodeColumns>
  <CodeColumn title="Terra">
    ```terra
    if iswindows() then
        terra waitatend()
            C.getchar()
        end
    else
        terra waitatend() end
    end
    ```
  </CodeColumn> 
  <CodeColumn title="C++">
    ```cpp
    #ifdef _WIN32
        void waitatend() { 
            getchar(); 
        }
    #else
        void waitatend() {}
    #endif
    ``` 
  </CodeColumn> 
</CodeColumns>
</details>


<details>
  <summary>Example: Namespaces</summary>

Statically-typed languages normally need constructs that specifically deal with the problem of namespaces (e.g., C++'s `namespace` keyword, or Java's `import` constructs). For Terra, we just use Lua's first-class tables as way to organize functions. When you use any "name" such as `myfunctions.add` inside a Terra function, the Terra will resolve it at _compile time_ to the Terra value it holds. Here is an example of placing a Terra function inside a Lua table, and then calling it from another Terra function:

```terra
local myfunctions = {}
-- terra functions are first-class Lua values

-- they can be stored in Lua tables
terra myfunctions.add(a : int, b : int) : int
    return a + b
end

-- and called from the tables as well
terra myfunctions.add3(a : int)
    return myfunctions.add(a,3)
end

--the declaration of myfunctions.add is just syntax sugar for:

myfunctions["add"] = terra(a : int, b : int) : int
    return a + b
end

print(myfunctions.add3(4))
```

In fact, you've already seen this behavior when we imported C functions:

```terra
C = terralib.includec("stdio.h")
```

The function `includec` just returns a Lua table (`C`) that contains the C functions. Since `C` is a Lua table, you can iterate through it if you want:

```terra
for k,v in pairs(C) do
    print(k,v)
end

-- seek         <terra function>
-- asprintf     <terra function>
-- gets         <terra function>
-- size_t       uint64
-- ...
```
</details>

<details>
  <summary>Example: Templated types</summary>

Templates become Lua functions that take a terra type T and use it to generate new types and code.
<CodeColumns>
  <CodeColumn title="Terra">
    ```terra
    function Array(T)
        struct Array {
            N : int
            data : &T
        }
        terra Array:get(i : int)
            return self.data[i]
        end
        return Array
    end

    FloatArray = Array(float)
    ```
  </CodeColumn> 
  <CodeColumn title="C++">
    ```cpp
    template<class T>
    struct Array {
        int N;
        T* data;

        T get(int i) {
            return data[i];
        }

    };
    
    typedef Array<float> FloatArray;
    ``` 
  </CodeColumn> 
</CodeColumns>

</details>

<details>
  <summary>Example: loop unrolling in polynomial evaluation</summary>

We explore loop unrolling in Terra for evaluating a cubic polynomial $ p(x) = a + b \cdot x + c \cdot x^2 + d \cdot x^3 $, where coefficients are stored in a struct array (`coeffs[0] = a`, `coeffs[1] = b`,  `coeffs[2] = c`,  `coeffs[3] = d`.). Horner's method rewrites the polynomial as $ a + x \cdot (b + x \cdot (c + x \cdot d)) $ to minimize multiplications and additions, improving numerical stability and performance.

Terra's metaprogramming capabilities allow us to unroll loops at compile time, generating explicit, optimized code without runtime overhead. The following code defines a generic, templated Polynomial evaluator supporting float or double types. It uses loop unrolling in the eval method to produce efficient, branch-free code.

```terra file=./tutorials/tutorial-resource-management/tutorial-poly-standard.t start=poly_start end=poly_end
```
To create a cubic polynomial type with float coefficients:
```terra 
local poly = Polynomial(float, 4) -- Generates and caches the type
```
Inspect the unrolled eval method using `:printpretty()` to see the expanded Terra code:
```
tutorial-poly.t:31:     terra poly.eval(self : &poly,x : float) : float
tutorial-poly.t:32:         var y : float = [&float]((@self).coeffs)[3] -- c
tutorial-poly.t:36:         y = x * y + [&float]((@self).coeffs)[2]     -- x*d + c
tutorial-poly.t:36:         y = x * y + [&float]((@self).coeffs)[1]     -- x*(x*d + c) + b
tutorial-poly.t:36:         y = x * y + [&float]((@self).coeffs)[0]     -- x*(x*(x*d + c) + b) + a
tutorial-poly.t:40:         return y
tutorial-poly.t:31:     end
```
This shows the loop fully unrolled into sequential multiply-adds, ready for further optimization by the compiler.

View the generated assembly with `:disas()` (with -O3 on an AMD CPU):
```
assembly for function at address 0x722b5a3bb000
0x722b5a3bb000(+0):             vmulsd  xmm1, xmm0, qword ptr [rdi + 24]
0x722b5a3bb005(+5):             vaddsd  xmm1, xmm1, qword ptr [rdi + 16]
0x722b5a3bb00a(+10):            vmulsd  xmm1, xmm1, xmm0
0x722b5a3bb00e(+14):            vaddsd  xmm1, xmm1, qword ptr [rdi + 8]
0x722b5a3bb013(+19):            vmulsd  xmm0, xmm1, xmm0
0x722b5a3bb017(+23):            vaddsd  xmm0, xmm0, qword ptr [rdi]
0x722b5a3bb01b(+27):            ret
```
This code is already quite efficient with 7 instructions (3 multiplies, 3 adds, 1 return) and 3 registers (an input/output register `xmm0`, a register `xmm1` to hold a temporary, and a general purpose register `rdi` to point to the coefficient array). 

</details>

<details>
  <summary>Example: Optimizing with LLVM Intrinsics for fused-multiply-addition (FMA) </summary>

We can further optimize the code of the previous example by fusing the addition and multiplication into one operation. The intrinsic (llvm.fma.f64 or llvm.fma.f32) ensures the compiler emits hardware FMA instructions (e.g., vfmadd213sd), reducing instruction count, latency, and rounding errors.

Here's the optimized code integrated into the Polynomial factory (replace the original eval method and add the intrinsic definition):
```terra file=./tutorials/tutorial-resource-management/tutorial-poly-optimized.t start=polyeval_start end=polyeval_end
```

The Terra intrinsic declaration maps directly to LLVM's FMA operation, selecting `llvm.fma.f32` for floats or `llvm.fma.f64` for doubles based on type `T`. It takes three `T` arguments (x, y, z) and returns `T`, computing $ x \cdot y + z $—perfect for Horner's nesting. This results in the following assembly with 5 instructions and 3 fused-multiply-adds.
```
assembly for function at address 0x736c9cc8a000
0x736c9cc8a000(+0):             vmovsd  xmm1, qword ptr [rdi + 24]
0x736c9cc8a005(+5):             vfmadd213sd     xmm1, xmm0, qword ptr [rdi + 16]
0x736c9cc8a00b(+11):            vfmadd213sd     xmm1, xmm0, qword ptr [rdi + 8]
0x736c9cc8a011(+17):            vfmadd213sd     xmm0, xmm1, qword ptr [rdi]
0x736c9cc8a016(+22):            ret
```
</details>



## Implementing Compiler Features as Libraries
Multistage programming empowers users to implement language extensions—typically reserved for compiler developers—as simple Lua libraries. This capability stems from Terra's design: Lua serves as a staging language to generate and specialize Terra code dynamically at compile time. Features like lambdas, generics, or custom optimizations can be built modularly without altering the core compiler, enabling rapid prototyping, better portability, and user-defined DSLs. It's even possible to extend Terra's parser from outside the language by adding new keywords with associated logic in a library. This library-based approach democratizes language design, shifting complexity from monolithic compilers to reusable modules, and reduces overhead by generating efficient, specialized code on-the-fly.

<details>
  <summary>Example: Implementing Lambdas as a Library in Terra </summary>

In traditional languages, lambdas (anonymous functions with captures) require compiler support for closure creation, variable capturing, and invocation. In Terra, multistage programming allows this to be implemented concisely as a Lua library using macros and structs. The following code creates function objects that wrap a Terra function, capture variables in a struct, and overload the apply metamethod for invocation. It's only a few lines, demonstrating the power of multistage programming to implement compiler features.

```terra file=./tutorials/tutorial-resource-management/liblambda.t start=lambda_new_start end=lambda_new_end
```
By loading this small library you can define and use lambda's as follows:
```terra file=./tutorials/tutorial-resource-management/tutorial-lambda.t start=tutorial_lambda_start end=tutorial_lambda_end
```
</details>

<details>
  <summary>Example: Implementing Run-Time Type Information (RTTI) as a Library in Terra </summary>

In C++, Run-Time Type Information (RTTI) is a built-in language feature implemented in the compiler for dynamic type checking and casting. In Terra, multistage programming allows RTTI to be implemented entirely as a Lua library outside the compiler, adding type IDs to structs and enabling dynamic casts with minimal code.

RTTI provides run-time identification of object types, useful for dynamic casting or polymorphism. The library assigns unique IDs to types, inserts them as fields in structs, and offers functions for querying and casting—mirroring C++'s typeid and dynamic_cast but in a lightweight, user-extensible module.

Implementing RTTI as a library benefits from modularity (easy updates without recompiling Terra), portability (no compiler dependencies), and customization (users can modify ID generation or add features). It leverages Lua's metaprogramming to insert fields and initializers dynamically, demonstrating how multistage programming shifts compiler-like features to libraries.

```terra file=./tutorials/tutorial-resource-management/librtti.t start=rtti_start end=rtti_end
```

The following test demonstrates dynamic casting: `f` identifies and prints the type of opaque pointers to `A` or `B` instances by performing a dynamic cast.
```terra file=./tutorials/tutorial-resource-management/tutorial-rtti.t start=tutorial_rtti_start end=tutorial_rtti_end
```
</details>


<details>
  <summary>Example: Concept-Based Template Dispatch as a Library Extension </summary>

Template dispatch selects the appropriate function overload at compile time based on argument types and constraints, improving type safety and expressiveness. Concepts define requirements on template parameters (e.g., Real for floating-point types, Integer for integers), ensuring only valid instantiations are allowed and providing clear error messages for mismatches.

The new standard library implements templated overloading of functions and methods, with template constraints via concepts—mirroring C++20's capabilities but in a modular library. This library uses Terra's unique feature to extend the parser from outside the language with a new keyword, `terraform`, with the dispatch logic implemented in the library.

Implementing this as a library offers key benefits: modularity (easy to update or replace), no core compiler modifications (faster iteration, better portability), and extensibility (users can add custom concepts or dispatch rules). It leverages Lua's metaprogramming to generate specialized code, reducing runtime overhead while keeping the language lightweight.

```terra file=./tutorials/tutorial-resource-management/tutorial-concepts.t start=tutorial_terraform_start end=tutorial_terraform_end
```
</details>