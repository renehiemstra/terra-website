---
id: multistage-programming
title: Multistage programming
---

import { CodeColumns, CodeColumn } from '../../src/components/CodeColumns';

__Terra__ is a low-level system programming language that is embedded in and meta-programmed by the __Lua__ programming language:
```terra
--This top-level code is plain Lua code.
function printhello()
    -- This is a plain Lua function
    print("Hello, Lua!")
end
printhello()

-- Terra is backwards compatible with C, we'll use C's io library in our example.
C = terralib.includec("stdio.h")

-- The keyword 'terra' introduces a new Terra function.
terra hello(argc : int, argv : &rawstring)
    -- Here we call a C function from Terra
    C.printf("Hello, Terra!\n")
    return 0
end

-- You can call Terra functions directly from Lua, they are JIT compiled 
-- using LLVM to create machine code
hello(0,nil)

-- Terra functions are first-class values in Lua, and can be introspected 
-- and meta-programmed using it
hello:disas()
--[[ output:
    assembly for function at address 0x60e6010
    0x60e6010(+0):		push	rax
    0x60e6011(+1):		movabs	rdi, 102129664
    0x60e601b(+11):		movabs	rax, 140735712154681
    0x60e6025(+21):		call	rax
    0x60e6027(+23):		xor	eax, eax
    0x60e6029(+25):		pop	rdx
    0x60e602a(+26):		ret
]]

-- You can save Terra code as executables, object files, or shared libraries 
-- and link them into existing programs
terralib.saveobj("helloterra",{ main = hello })
```
Try this example and others in your browser via [Replit](https://replit.com/@terralang/terra).

Like C/C++, Terra is a  **statically-typed**, **compiled language** with manual memory management. 
But unlike C/C++, it is designed from the beginning to be **meta-programmed from Lua**. 

The design of Terra comes from the realization that C/C++ is really composed of multiple "languages." It has a core language of operators, control-flow, and functions calls, but surrounding this language is a meta-language composed of a mix of features such as the pre-processor, templating system, and struct definitions. Templates alone are Turing-complete and have been used to produce optimized libraries such as [Eigen](http://eigen.tuxfamily.org/index.php?title=Main_Page), but are horrible to use in practice. 

In Terra, we just gave in to the trend of making the meta-language of C/C++ more powerful and replaced it with a real programming language, Lua. 

The combination of a low-level language meta-programmed by a high-level scripting language allows many behaviors that are not possible in other systems. Unlike C/C++, Terra code can be JIT-compiled and run interleaved with Lua evaluation, making it easy to write software libraries that depend on runtime code generation. 

Features of other languages such as conditional compilation and templating simply fall out of the combination of using Lua to meta-program Terra:
<CodeColumns>
  <CodeColumn>
    ```terra
    terra add(a : int,b : int) : int
        return a + b
    end
    ```
  </CodeColumn> 
  <CodeColumn> 
    ```cpp
    int add(int a, int b) {
        return a + b;
    }
    ``` 
  </CodeColumn> 
</CodeColumns>

<CodeColumns>
  <CodeColumn>
    ```terra
    if iswindows() then
        terra waitatend()
            C.getchar()
        end
    else
        terra waitatend() end
    end
    ```
  </CodeColumn> 
  <CodeColumn> 
    ```cpp
    #ifdef _WIN32
        void waitatend() { 
            getchar(); 
        }
    #else
        void waitatend() {}
    #endif
    ``` 
  </CodeColumn> 
</CodeColumns>

<CodeColumns>
  <CodeColumn>
    ```terra
    function Array(T)
        struct Array {
            N : int
            data : &T
        }
        terra Array:get(i : int)
            return self.data[i]
        end
        return Array
    end

    FloatArray = Array(float)
    ```
  </CodeColumn> 
  <CodeColumn> 
    ```cpp
    template<class T>
    struct Array {
        int N;
        T* data;

        T get(int i) {
            return data[i];
        }

    };
    
    typedef Array<float> FloatArray;
    ``` 
  </CodeColumn> 
</CodeColumns>